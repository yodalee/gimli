var searchIndex = {};
searchIndex["gimli"] = {"doc":"A lazy, zero-copy parser for the DWARF debugging information format.","items":[[3,"DebugFrameOffset","gimli","An offset into the `.debug_frame` section.",null,null],[12,"0","","",0,null],[3,"DebugFrame","","The `DebugFrame` struct contains the source location to instruction mapping\nfound in the `.debug_frame` section.",null,null],[3,"CfiEntriesIter","","An iterator over CIE and FDE entries in a `.debug_frame` section.",null,null],[3,"CommonInformationEntry","","&gt; A Common Information Entry holds information that is shared among many\n&gt; Frame Description Entries. There is at least one CIE in every non-empty\n&gt; `.debug_frame` section.",null,null],[3,"PartialFrameDescriptionEntry","","A partially parsed `FrameDescriptionEntry`.",null,null],[3,"FrameDescriptionEntry","","A `FrameDescriptionEntry` is a set of CFA instructions for an address range.",null,null],[3,"UninitializedUnwindContext","","Common context needed when evaluating the call frame unwinding information.",null,null],[3,"InitializedUnwindContext","","An initialized unwinding context.",null,null],[3,"UnwindTable","","The `UnwindTable` iteratively evaluates a `FrameDescriptionEntry`&#39;s\n`CallFrameInstruction` program, yielding the each row one at a time.",null,null],[3,"UnwindTableRow","","A row in the virtual unwind table that describes how to find the values of\nthe registers in the *previous* frame for a range of PC addresses.",null,null],[3,"CallFrameInstructionIter","","A lazy iterator parsing call frame instructions.",null,null],[3,"DwCfa","","",null,null],[12,"0","","",1,null],[3,"DwChildren","","",null,null],[12,"0","","",2,null],[3,"DwTag","","",null,null],[12,"0","","",3,null],[3,"DwAt","","",null,null],[12,"0","","",4,null],[3,"DwForm","","",null,null],[12,"0","","",5,null],[3,"DwAte","","",null,null],[12,"0","","",6,null],[3,"DwDs","","",null,null],[12,"0","","",7,null],[3,"DwEnd","","",null,null],[12,"0","","",8,null],[3,"DwAccess","","",null,null],[12,"0","","",9,null],[3,"DwVis","","",null,null],[12,"0","","",10,null],[3,"DwVirtuality","","",null,null],[12,"0","","",11,null],[3,"DwLang","","",null,null],[12,"0","","",12,null],[3,"DwAddr","","",null,null],[12,"0","","",13,null],[3,"DwId","","",null,null],[12,"0","","",14,null],[3,"DwCc","","",null,null],[12,"0","","",15,null],[3,"DwInl","","",null,null],[12,"0","","",16,null],[3,"DwOrd","","",null,null],[12,"0","","",17,null],[3,"DwDsc","","",null,null],[12,"0","","",18,null],[3,"DwLns","","",null,null],[12,"0","","",19,null],[3,"DwLne","","",null,null],[12,"0","","",20,null],[3,"DwOp","","",null,null],[12,"0","","",21,null],[3,"EndianBuf","","A `&amp;[u8]` slice with compile-time endianity metadata.",null,null],[12,"0","","",22,null],[12,"1","","",22,null],[3,"DebugMacinfoOffset","","An offset into the `.debug_macinfo` section.",null,null],[12,"0","","",23,null],[3,"DebugAbbrev","","The `DebugAbbrev` struct represents the abbreviations describing\n`DebuggingInformationEntry`s&#39; attribute names and forms found in the\n`.debug_abbrev` section.",null,null],[3,"DebugAbbrevOffset","","An offset into the `.debug_abbrev` section.",null,null],[12,"0","","",24,null],[3,"Abbreviations","","A set of type abbreviations.",null,null],[3,"Abbreviation","","An abbreviation describes the shape of a `DebuggingInformationEntry`&#39;s type:\nits code, tag type, whether it has children, and its set of attributes.",null,null],[3,"AttributeSpecification","","The description of an attribute in an abbreviated type. It is a pair of name\nand form.",null,null],[3,"ArangeEntry","","A single parsed arange.",null,null],[3,"DebugLineOffset","","An offset into the `.debug_line` section.",null,null],[12,"0","","",25,null],[3,"DebugLine","","The `DebugLine` struct contains the source location to instruction mapping\nfound in the `.debug_line` section.",null,null],[3,"StateMachine","","Executes a `LineNumberProgram` to recreate the matrix mapping to and from\ninstructions to source locations.",null,null],[3,"OpcodesIter","","An iterator yielding parsed opcodes.",null,null],[3,"LineNumberRow","","A row in the line number program&#39;s resulting matrix.",null,null],[3,"LineNumberProgramHeader","","A header for a line number program in the `.debug_line` section, as defined\nin section 6.2.4 of the standard.",null,null],[3,"FileEntry","","An entry in the `LineNumberProgramHeader`&#39;s `file_names` set.",null,null],[3,"DebugLoc","","The `DebugLoc` struct represents the DWARF strings\nfound in the `.debug_loc` section.",null,null],[3,"DebugLocOffset","","An offset into the `.debug_loc` section.",null,null],[12,"0","","",26,null],[3,"LocationListIter","","An iterator over a location list.",null,null],[3,"RawLocationListIter","","A raw iterator over a location list.",null,null],[3,"LocationListEntry","","A location list entry from the `.debug_loc` section.",null,null],[12,"range","","The address range that this location is valid for.",27,null],[12,"data","","The data containing a single location description.",27,null],[3,"Piece","","The description of a single piece of the result of a DWARF\nexpression.",null,null],[12,"size_in_bits","","If given, the size of the piece in bits.  If `None`, then the\npiece takes its size from the enclosed location.",28,null],[12,"bit_offset","","If given, the bit offset of the piece.  If `None`, then the\npiece starts at the next byte boundary.",28,null],[12,"location","","Where this piece is to be found.",28,null],[3,"Evaluation","","A DWARF expression evaluation.",null,null],[3,"PubNamesEntry","","A single parsed pubname.",null,null],[3,"PubTypesEntry","","A single parsed pubtype.",null,null],[3,"DebugRanges","","The `DebugRanges` struct represents the DWARF strings\nfound in the `.debug_ranges` section.",null,null],[3,"DebugRangesOffset","","An offset into the `.debug_ranges` section.",null,null],[12,"0","","",29,null],[3,"RangesIter","","An iterator over an address range list.",null,null],[3,"RawRangesIter","","A raw iterator over an address range list.",null,null],[3,"Range","","An address range from the `.debug_ranges` section.",null,null],[12,"begin","","The beginning address of the range.",30,null],[12,"end","","The first address past the end of the range.",30,null],[3,"DebugStrOffset","","An offset into the `.debug_str` section.",null,null],[12,"0","","",31,null],[3,"DebugStr","","The `DebugStr` struct represents the DWARF strings\nfound in the `.debug_str` section.",null,null],[3,"DebugInfo","","The `DebugInfo` struct represents the DWARF debugging information found in\nthe `.debug_info` section.",null,null],[3,"DebugInfoOffset","","An offset into the `.debug_info` section.",null,null],[12,"0","","",32,null],[3,"CompilationUnitHeadersIter","","An iterator over the compilation- and partial-units of a section.",null,null],[3,"CompilationUnitHeader","","The header of a compilation unit&#39;s debugging information.",null,null],[3,"UnitOffset","","An offset into the current compilation or type unit.",null,null],[12,"0","","",33,null],[3,"DebugTypes","","The `DebugTypes` struct represents the DWARF type information\nfound in the `.debug_types` section.",null,null],[3,"DebugTypesOffset","","An offset into the `.debug_types` section.",null,null],[12,"0","","",34,null],[3,"DebugTypeSignature","","A type signature as used in the `.debug_types` section.",null,null],[12,"0","","",35,null],[3,"TypeUnitHeadersIter","","An iterator over the type-units of this `.debug_types` section.",null,null],[3,"TypeUnitHeader","","The header of a type unit&#39;s debugging information.",null,null],[3,"EntriesCursor","","A cursor into the Debugging Information Entries tree for a compilation unit.",null,null],[3,"DebuggingInformationEntry","","A Debugging Information Entry (DIE).",null,null],[3,"AttrsIter","","An iterator over a particular entry&#39;s attributes.",null,null],[3,"Attribute","","An attribute in a `DebuggingInformationEntry`, consisting of a name and\nassociated value.",null,null],[4,"CieOrFde","","Either a `CommonInformationEntry` (CIE) or a `FrameDescriptionEntry` (FDE).",null,null],[13,"Cie","","This CFI entry is a `CommonInformationEntry`.",36,null],[13,"Fde","","This CFI entry is a `FrameDescriptionEntry`, however fully parsing it\nrequires parsing its CIE first, so it is left in a partially parsed\nstate.",36,null],[4,"CfaRule","","The canonical frame address (CFA) recovery rules.",null,null],[13,"RegisterAndOffset","","The CFA is given offset from the given register&#39;s value.",37,null],[12,"register","gimli::CfaRule","The register containing the base value.",37,null],[12,"offset","","The offset from the register&#39;s base value.",37,null],[13,"Expression","gimli","The CFA is obtained by evaluating this `EndianBuf` as a DWARF expression\nprogram.",37,null],[4,"RegisterRule","","An entry in the abstract CFI table that describes how to find the value of a\nregister.",null,null],[13,"Undefined","","&gt; A register that has this rule has no recoverable value in the previous\n&gt; frame. (By convention, it is not preserved by a callee.)",38,null],[13,"SameValue","","&gt; This register has not been modified from the previous frame. (By\n&gt; convention, it is preserved by the callee, but the callee has not\n&gt; modified it.)",38,null],[13,"Offset","","&quot;The previous value of this register is saved at the address CFA+N where\nCFA is the current CFA value and N is a signed offset.&quot;",38,null],[13,"ValOffset","","&quot;The previous value of this register is the value CFA+N where CFA is the\ncurrent CFA value and N is a signed offset.&quot;",38,null],[13,"Register","","&quot;The previous value of this register is stored in another register\nnumbered R.&quot;",38,null],[13,"Expression","","&quot;The previous value of this register is located at the address produced\nby executing the DWARF expression.&quot;",38,null],[13,"ValExpression","","&quot;The previous value of this register is the value produced by executing\nthe DWARF expression.&quot;",38,null],[13,"Architectural","","&quot;The rule is defined externally to this specification by the augmenter.&quot;",38,null],[4,"CallFrameInstruction","","A parsed call frame instruction.",null,null],[13,"SetLoc","","&gt; 1. DW_CFA_set_loc\n&gt;\n&gt; The DW_CFA_set_loc instruction takes a single operand that represents\n&gt; a target address. The required action is to create a new table row\n&gt; using the specified address as the location. All other values in the\n&gt; new row are initially identical to the current row. The new location\n&gt; value is always greater than the current one. If the segment_size\n&gt; field of this FDE&#39;s CIE is non- zero, the initial location is preceded\n&gt; by a segment selector of the given length.",39,null],[12,"address","gimli::CallFrameInstruction","The target address.",39,null],[13,"AdvanceLoc","gimli","The `AdvanceLoc` instruction is used for all of `DW_CFA_advance_loc` and\n`DW_CFA_advance_loc{1,2,4}`.",39,null],[12,"delta","gimli::CallFrameInstruction","The delta to be added to the current address.",39,null],[13,"DefCfa","gimli","&gt; 1. DW_CFA_def_cfa\n&gt;\n&gt; The DW_CFA_def_cfa instruction takes two unsigned LEB128 operands\n&gt; representing a register number and a (non-factored) offset. The\n&gt; required action is to define the current CFA rule to use the provided\n&gt; register and offset.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"offset","","The non-factored offset.",39,null],[13,"DefCfaSf","gimli","&gt; 2. DW_CFA_def_cfa_sf\n&gt;\n&gt; The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number and a signed LEB128\n&gt; factored offset. This instruction is identical to DW_CFA_def_cfa\n&gt; except that the second operand is signed and factored. The resulting\n&gt; offset is factored_offset * data_alignment_factor.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"factored_offset","","The factored offset.",39,null],[13,"DefCfaRegister","gimli","&gt; 3. DW_CFA_def_cfa_register\n&gt;\n&gt; The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128\n&gt; operand representing a register number. The required action is to\n&gt; define the current CFA rule to use the provided register (but to keep\n&gt; the old offset). This operation is valid only if the current CFA rule\n&gt; is defined to use a register and offset.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[13,"DefCfaOffset","gimli","&gt; 4. DW_CFA_def_cfa_offset\n&gt;\n&gt; The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128\n&gt; operand representing a (non-factored) offset. The required action is\n&gt; to define the current CFA rule to use the provided offset (but to keep\n&gt; the old register). This operation is valid only if the current CFA\n&gt; rule is defined to use a register and offset.",39,null],[12,"offset","gimli::CallFrameInstruction","The non-factored offset.",39,null],[13,"DefCfaOffsetSf","gimli","&gt; 5. DW_CFA_def_cfa_offset_sf\n&gt;\n&gt; The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand\n&gt; representing a factored offset. This instruction is identical to\n&gt; DW_CFA_def_cfa_offset except that the operand is signed and\n&gt; factored. The resulting offset is factored_offset *\n&gt; data_alignment_factor. This operation is valid only if the current CFA\n&gt; rule is defined to use a register and offset.",39,null],[12,"factored_offset","gimli::CallFrameInstruction","The factored offset.",39,null],[13,"DefCfaExpression","gimli","&gt; 6. DW_CFA_def_cfa_expression\n&gt;\n&gt; The DW_CFA_def_cfa_expression instruction takes a single operand\n&gt; encoded as a DW_FORM_exprloc value representing a DWARF\n&gt; expression. The required action is to establish that expression as the\n&gt; means by which the current CFA is computed.",39,null],[12,"expression","gimli::CallFrameInstruction","The DWARF expression.",39,null],[13,"Undefined","gimli","&gt; 1. DW_CFA_undefined\n&gt;\n&gt; The DW_CFA_undefined instruction takes a single unsigned LEB128\n&gt; operand that represents a register number. The required action is to\n&gt; set the rule for the specified register to “undefined.”",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[13,"SameValue","gimli","&gt; 2. DW_CFA_same_value\n&gt;\n&gt; The DW_CFA_same_value instruction takes a single unsigned LEB128\n&gt; operand that represents a register number. The required action is to\n&gt; set the rule for the specified register to “same value.”",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[13,"Offset","gimli","The `Offset` instruction represents both `DW_CFA_offset` and\n`DW_CFA_offset_extended`.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"factored_offset","","The factored offset.",39,null],[13,"OffsetExtendedSf","gimli","&gt; 5. DW_CFA_offset_extended_sf\n&gt;\n&gt; The DW_CFA_offset_extended_sf instruction takes two operands: an\n&gt; unsigned LEB128 value representing a register number and a signed\n&gt; LEB128 factored offset. This instruction is identical to\n&gt; DW_CFA_offset_extended except that the second operand is signed and\n&gt; factored. The resulting offset is factored_offset *\n&gt; data_alignment_factor.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"factored_offset","","The factored offset.",39,null],[13,"ValOffset","gimli","&gt; 6. DW_CFA_val_offset\n&gt;\n&gt; The DW_CFA_val_offset instruction takes two unsigned LEB128 operands\n&gt; representing a register number and a factored offset. The required\n&gt; action is to change the rule for the register indicated by the\n&gt; register number to be a val_offset(N) rule where the value of N is\n&gt; factored_offset * data_alignment_factor.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"factored_offset","","The factored offset.",39,null],[13,"ValOffsetSf","gimli","&gt; 7. DW_CFA_val_offset_sf\n&gt;\n&gt; The DW_CFA_val_offset_sf instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number and a signed LEB128\n&gt; factored offset. This instruction is identical to DW_CFA_val_offset\n&gt; except that the second operand is signed and factored. The resulting\n&gt; offset is factored_offset * data_alignment_factor.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"factored_offset","","The factored offset.",39,null],[13,"Register","gimli","&gt; 8. DW_CFA_register\n&gt;\n&gt; The DW_CFA_register instruction takes two unsigned LEB128 operands\n&gt; representing register numbers. The required action is to set the rule\n&gt; for the first register to be register(R) where R is the second\n&gt; register.",39,null],[12,"dest_register","gimli::CallFrameInstruction","The number of the register whose rule is being changed.",39,null],[12,"src_register","","The number of the register where the other register&#39;s value can be\nfound.",39,null],[13,"Expression","gimli","&gt; 9. DW_CFA_expression\n&gt;\n&gt; The DW_CFA_expression instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number, and a DW_FORM_block value\n&gt; representing a DWARF expression. The required action is to change the\n&gt; rule for the register indicated by the register number to be an\n&gt; expression(E) rule where E is the DWARF expression. That is, the DWARF\n&gt; expression computes the address. The value of the CFA is pushed on the\n&gt; DWARF evaluation stack prior to execution of the DWARF expression.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"expression","","The DWARF expression.",39,null],[13,"ValExpression","gimli","&gt; 10. DW_CFA_val_expression\n&gt;\n&gt; The DW_CFA_val_expression instruction takes two operands: an unsigned\n&gt; LEB128 value representing a register number, and a DW_FORM_block value\n&gt; representing a DWARF expression. The required action is to change the\n&gt; rule for the register indicated by the register number to be a\n&gt; val_expression(E) rule where E is the DWARF expression. That is, the\n&gt; DWARF expression computes the value of the given register. The value\n&gt; of the CFA is pushed on the DWARF evaluation stack prior to execution\n&gt; of the DWARF expression.",39,null],[12,"register","gimli::CallFrameInstruction","The target register&#39;s number.",39,null],[12,"expression","","The DWARF expression.",39,null],[13,"Restore","gimli","The `Restore` instruction represents both `DW_CFA_restore` and\n`DW_CFA_restore_extended`.",39,null],[12,"register","gimli::CallFrameInstruction","The register to be reset.",39,null],[13,"RememberState","gimli","&gt; 1. DW_CFA_remember_state\n&gt;\n&gt; The DW_CFA_remember_state instruction takes no operands. The required\n&gt; action is to push the set of rules for every register onto an implicit\n&gt; stack.",39,null],[13,"RestoreState","","&gt; 2. DW_CFA_restore_state\n&gt;\n&gt; The DW_CFA_restore_state instruction takes no operands. The required\n&gt; action is to pop the set of rules off the implicit stack and place\n&gt; them in the current row.",39,null],[13,"Nop","","&gt; 1. DW_CFA_nop\n&gt;\n&gt; The DW_CFA_nop instruction has no operands and no required actions. It\n&gt; is used as padding to make a CIE or FDE an appropriate size.",39,null],[4,"LittleEndian","","Little endian byte order.",null,null],[4,"BigEndian","","Big endian byte order.",null,null],[4,"Error","","An error that occurred when parsing.",null,null],[13,"BadUnsignedLeb128","","An error parsing an unsigned LEB128 value.",40,null],[13,"BadSignedLeb128","","An error parsing a signed LEB128 value.",40,null],[13,"AbbreviationTagZero","","An abbreviation declared that its tag is zero, but zero is reserved for\nnull records.",40,null],[13,"AttributeFormZero","","An attribute specification declared that its form is zero, but zero is\nreserved for null records.",40,null],[13,"BadHasChildren","","The abbreviation&#39;s has-children byte was not one of\n`DW_CHILDREN_{yes,no}`.",40,null],[13,"BadLength","","The specified length is impossible.",40,null],[13,"UnknownForm","","Found an unknown `DW_FORM_*` type.",40,null],[13,"ExpectedZero","","Expected a zero, found something else.",40,null],[13,"DuplicateAbbreviationCode","","Found an abbreviation code that has already been used.",40,null],[13,"DuplicateArange","","Found a duplicate arange.",40,null],[13,"UnknownReservedLength","","Found an unknown reserved length value.",40,null],[13,"UnknownVersion","","Found an unknown DWARF version.",40,null],[13,"UnitHeaderLengthTooShort","","The unit header&#39;s claimed length is too short to even hold the header\nitself.",40,null],[13,"UnknownAbbreviation","","Found a record with an unknown abbreviation code.",40,null],[13,"UnexpectedEof","","Hit the end of input before it was expected.",40,null],[13,"UnknownStandardOpcode","","Found an unknown standard opcode.",40,null],[13,"UnknownExtendedOpcode","","Found an unknown extended opcode.",40,null],[13,"UnsupportedAddressSize","","The specified address size is not supported.",40,null],[13,"UnsupportedFieldSize","","The specified field size is not supported.",40,null],[13,"MinimumInstructionLengthZero","","The minimum instruction length must not be zero.",40,null],[13,"MaximumOperationsPerInstructionZero","","The maximum operations per instruction must not be zero.",40,null],[13,"LineRangeZero","","The line range must not be zero.",40,null],[13,"OpcodeBaseZero","","The opcode base must not be zero.",40,null],[13,"BadUtf8","","Found an invalid UTF-8 string.",40,null],[13,"NotCieId","","Expected to find the CIE ID, but found something else.",40,null],[13,"NotCiePointer","","Expected to find a pointer to a CIE, but found the CIE ID instead.",40,null],[13,"BadBranchTarget","","Invalid branch target for a DW_OP_bra or DW_OP_skip.",40,null],[13,"InvalidPushObjectAddress","","DW_OP_push_object_address used but no address passed in.",40,null],[13,"NotEnoughStackItems","","Not enough items on the stack when evaluating an expression.",40,null],[13,"TooManyIterations","","Too many iterations to compute the expression.",40,null],[13,"InvalidExpression","","An unrecognized operation was found while parsing a DWARF\nexpression.",40,null],[13,"InvalidPiece","","The expression had a piece followed by an expression\nterminator without a piece.",40,null],[13,"InvalidExpressionTerminator","","An expression-terminating operation was followed by something\nother than the end of the expression or a piece operation.",40,null],[13,"DivisionByZero","","Division or modulus by zero when evaluating an expression.",40,null],[13,"UnknownCallFrameInstruction","","An unknown DW_CFA_* instruction.",40,null],[13,"InvalidAddressRange","","The end of an address range was before the beginning.",40,null],[13,"InvalidLocationAddressRange","","The end offset of a loc list entry was before the beginning.",40,null],[13,"CfiInstructionInInvalidContext","","Encountered a call frame instruction in a context in which it is not\nvalid.",40,null],[13,"PopWithEmptyStack","","When evaluating call frame instructions, found a `DW_CFA_restore_state`\nstack pop instruction, but the stack was empty, and had nothing to pop.",40,null],[13,"NoUnwindInfoForAddress","","Do not have unwind info for the given address.",40,null],[13,"UnsupportedOffset","","An offset value was larger than the maximum supported value.",40,null],[4,"Format","","Whether the format of a compilation unit is 32- or 64-bit.",null,null],[13,"Dwarf64","","64-bit DWARF",41,null],[13,"Dwarf32","","32-bit DWARF",41,null],[4,"Opcode","","A parsed line number program opcode.",null,null],[13,"Special","","&gt; ### 6.2.5.1 Special Opcodes\n&gt;\n&gt; Each ubyte special opcode has the following effect on the state machine:\n&gt;\n&gt;   1. Add a signed integer to the line register.\n&gt;\n&gt;   2. Modify the operation pointer by incrementing the address and\n&gt;   op_index registers as described below.\n&gt;\n&gt;   3. Append a row to the matrix using the current values of the state\n&gt;   machine registers.\n&gt;\n&gt;   4. Set the basic_block register to “false.”\n&gt;\n&gt;   5. Set the prologue_end register to “false.”\n&gt;\n&gt;   6. Set the epilogue_begin register to “false.”\n&gt;\n&gt;   7. Set the discriminator register to 0.\n&gt;\n&gt; All of the special opcodes do those same seven things; they differ from\n&gt; one another only in what values they add to the line, address and\n&gt; op_index registers.",42,null],[13,"Copy","","&quot;[`Opcode::Copy`] appends a row to the matrix using the current values of the state\nmachine registers. Then it sets the discriminator register to 0, and\nsets the basic_block, prologue_end and epilogue_begin registers to\n“false.”&quot;",42,null],[13,"AdvancePc","","&quot;The DW_LNS_advance_pc opcode takes a single unsigned LEB128 operand as\nthe operation advance and modifies the address and op_index registers\n[the same as `Opcode::Special`]&quot;",42,null],[13,"AdvanceLine","","&quot;The DW_LNS_advance_line opcode takes a single signed LEB128 operand and\nadds that value to the line register of the state machine.&quot;",42,null],[13,"SetFile","","&quot;The DW_LNS_set_file opcode takes a single unsigned LEB128 operand and\nstores it in the file register of the state machine.&quot;",42,null],[13,"SetColumn","","&quot;The DW_LNS_set_column opcode takes a single unsigned LEB128 operand and\nstores it in the column register of the state machine.&quot;",42,null],[13,"NegateStatement","","&quot;The DW_LNS_negate_stmt opcode takes no operands. It sets the is_stmt\nregister of the state machine to the logical negation of its current\nvalue.&quot;",42,null],[13,"SetBasicBlock","","&quot;The DW_LNS_set_basic_block opcode takes no operands. It sets the\nbasic_block register of the state machine to “true.”&quot;",42,null],[13,"ConstAddPc","","&gt; The DW_LNS_const_add_pc opcode takes no operands. It advances the\n&gt; address and op_index registers by the increments corresponding to\n&gt; special opcode 255.\n&gt;\n&gt; When the line number program needs to advance the address by a small\n&gt; amount, it can use a single special opcode, which occupies a single\n&gt; byte. When it needs to advance the address by up to twice the range of\n&gt; the last special opcode, it can use DW_LNS_const_add_pc followed by a\n&gt; special opcode, for a total of two bytes. Only if it needs to advance\n&gt; the address by more than twice that range will it need to use both\n&gt; DW_LNS_advance_pc and a special opcode, requiring three or more bytes.",42,null],[13,"FixedAddPc","","&gt; The DW_LNS_fixed_advance_pc opcode takes a single uhalf (unencoded)\n&gt; operand and adds it to the address register of the state machine and\n&gt; sets the op_index register to 0. This is the only standard opcode whose\n&gt; operand is not a variable length number. It also does not multiply the\n&gt; operand by the minimum_instruction_length field of the header.",42,null],[13,"SetPrologueEnd","","&quot;[`Opcode::SetPrologueEnd`] sets the prologue_end register to “true”.&quot;",42,null],[13,"SetEpilogueBegin","","&quot;[`Opcode::SetEpilogueBegin`] sets the epilogue_begin register to\n“true”.&quot;",42,null],[13,"SetIsa","","&quot;The DW_LNS_set_isa opcode takes a single unsigned LEB128 operand and\nstores that value in the isa register of the state machine.&quot;",42,null],[13,"UnknownStandard0","","An unknown standard opcode with zero operands.",42,null],[13,"UnknownStandard1","","An unknown standard opcode with one operand.",42,null],[13,"UnknownStandardN","","An unknown standard opcode with multiple operands.",42,null],[13,"EndSequence","","&gt; [`Opcode::EndSequence`] sets the end_sequence register of the state\n&gt; machine to “true” and appends a row to the matrix using the current\n&gt; values of the state-machine registers. Then it resets the registers to\n&gt; the initial values specified above (see Section 6.2.2). Every line\n&gt; number program sequence must end with a DW_LNE_end_sequence instruction\n&gt; which creates a row whose address is that of the byte after the last\n&gt; target machine instruction of the sequence.",42,null],[13,"SetAddress","","&gt; The DW_LNE_set_address opcode takes a single relocatable address as an\n&gt; operand. The size of the operand is the size of an address on the target\n&gt; machine. It sets the address register to the value given by the\n&gt; relocatable address and sets the op_index register to 0.\n&gt;\n&gt; All of the other line number program opcodes that affect the address\n&gt; register add a delta to it. This instruction stores a relocatable value\n&gt; into it instead.",42,null],[13,"DefineFile","","Defines a new source file in the line number program and appends it to\nthe line number program header&#39;s list of source files.",42,null],[13,"SetDiscriminator","","&quot;The DW_LNE_set_discriminator opcode takes a single parameter, an\nunsigned LEB128 integer. It sets the discriminator register to the new\nvalue.&quot;",42,null],[13,"UnknownExtended","","An unknown extended opcode and the slice of its unparsed operands.",42,null],[4,"ColumnType","","The type of column that a row is referring to.",null,null],[13,"LeftEdge","","The `LeftEdge` means that the statement begins at the start of the new\nline.",43,null],[13,"Column","","A column number, whose range begins at 1.",43,null],[4,"DieReference","","A reference to a DIE, either relative to the current CU or\nrelative to the section.",null,null],[13,"UnitRef","","A CU-relative reference.",44,null],[13,"DebugInfoRef","","A section-relative reference.",44,null],[4,"Operation","","A single decoded DWARF expression operation.",null,null],[13,"Deref","","A dereference operation.",45,null],[12,"size","gimli::Operation","The size of the data to dereference.",45,null],[12,"space","","True if the dereference operation takes an address space\nargument; false otherwise.",45,null],[13,"Drop","gimli","Drop an item from the stack.",45,null],[13,"Pick","","Pick an item from the stack and push it on top of the stack.\nThis operation handles `DW_OP_pick`, `DW_OP_dup`, and\n`DW_OP_over`.",45,null],[12,"index","gimli::Operation","The index, from the top of the stack, of the item to copy.",45,null],[13,"Swap","gimli","Swap the top two stack items.",45,null],[13,"Rot","","Rotate the top three stack items.",45,null],[13,"Abs","","Take the absolute value of the top of the stack.",45,null],[13,"And","","Bitwise `and` of the top two values on the stack.",45,null],[13,"Div","","Divide the top two values on the stack.",45,null],[13,"Minus","","Subtract the top two values on the stack.",45,null],[13,"Mod","","Modulus of the top two values on the stack.",45,null],[13,"Mul","","Multiply the top two values on the stack.",45,null],[13,"Neg","","Negate the top of the stack.",45,null],[13,"Not","","Bitwise `not` of the top of the stack.",45,null],[13,"Or","","Bitwise `or` of the top two values on the stack.",45,null],[13,"Plus","","Add the top two values on the stack.",45,null],[13,"PlusConstant","","Add a constant to the topmost value on the stack.",45,null],[12,"value","gimli::Operation","The value to add.",45,null],[13,"Shl","gimli","Logical left shift of the 2nd value on the stack by the number\nof bits given by the topmost value on the stack.",45,null],[13,"Shr","","Right shift of the 2nd value on the stack by the number of\nbits given by the topmost value on the stack.",45,null],[13,"Shra","","Arithmetic left shift of the 2nd value on the stack by the\nnumber of bits given by the topmost value on the stack.",45,null],[13,"Xor","","Bitwise `xor` of the top two values on the stack.",45,null],[13,"Bra","","Branch to the target location if the top of stack is nonzero.",45,null],[12,"target","gimli::Operation","The target bytecode.",45,null],[13,"Eq","gimli","Compare the top two stack values for equality.",45,null],[13,"Ge","","Compare the top two stack values using `&gt;=`.",45,null],[13,"Gt","","Compare the top two stack values using `&gt;`.",45,null],[13,"Le","","Compare the top two stack values using `&lt;=`.",45,null],[13,"Lt","","Compare the top two stack values using `&lt;`.",45,null],[13,"Ne","","Compare the top two stack values using `!=`.",45,null],[13,"Skip","","Unconditional branch to the target location.",45,null],[12,"target","gimli::Operation","The target bytecode.",45,null],[13,"Literal","gimli","Push a constant value on the stack.  This handles multiple\nDWARF opcodes, including `DW_OP_addr`.",45,null],[12,"value","gimli::Operation","The value to push.",45,null],[13,"Register","gimli","Indicate that this piece&#39;s location is in the given register.",45,null],[12,"register","gimli::Operation","The register number.",45,null],[13,"RegisterOffset","gimli","Find the value of the given register, add the offset, and then\npush the resulting sum on the stack.",45,null],[12,"register","gimli::Operation","The register number.",45,null],[12,"offset","","The offset to add.",45,null],[13,"FrameOffset","gimli","Compute the frame base (using `DW_AT_frame_base`), add the\ngiven offset, and then push the resulting sum on the stack.",45,null],[12,"offset","gimli::Operation","The offset to add.",45,null],[13,"Nop","gimli","No operation.",45,null],[13,"PushObjectAddress","","Push the object address on the stack.",45,null],[13,"Call","","Evaluate a DWARF expression as a subroutine.  The expression\ncomes from the `DW_AT_location` attribute of the indicated\nDIE.",45,null],[12,"offset","gimli::Operation","The DIE to use.",45,null],[13,"TLS","gimli","Compute the address of a thread-local variable and push it on\nthe stack.",45,null],[13,"CallFrameCFA","","Compute the call frame CFA and push it on the stack.",45,null],[13,"Piece","","Terminate a piece.",45,null],[12,"size_in_bits","gimli::Operation","The size of this piece in bits.",45,null],[12,"bit_offset","","The bit offset of this piece.  If `None`, then this piece\nwas specified using `DW_OP_piece` and should start at the\nnext byte boundary.",45,null],[13,"ImplicitValue","gimli","Represents `DW_OP_implicit_value`.",45,null],[12,"data","gimli::Operation","The implicit value to use.",45,null],[13,"StackValue","gimli","Represents `DW_OP_stack_value`.",45,null],[4,"Location","","A single location of a piece of the result of a DWARF expression.",null,null],[13,"Empty","","The piece is empty.  Ordinarily this means the piece has been\noptimized away.",46,null],[13,"Register","","The piece is found in a register.",46,null],[12,"register","gimli::Location","The register number.",46,null],[13,"Address","gimli","The piece is found in memory.",46,null],[12,"address","gimli::Location","The address.",46,null],[13,"Scalar","gimli","The piece is a scalar value.",46,null],[12,"value","gimli::Location","The value.",46,null],[13,"Bytes","gimli","The piece is represented by some constant bytes.",46,null],[12,"value","gimli::Location","The value.",46,null],[4,"AttributeValue","gimli","The value of an attribute in a `DebuggingInformationEntry`.",null,null],[13,"Addr","","&quot;Refers to some location in the address space of the described program.&quot;",47,null],[13,"Block","","A slice of an arbitrary number of bytes.",47,null],[13,"Data","","A one, two, four, or eight byte constant data value. How to interpret\nthe bytes depends on context.",47,null],[13,"Sdata","","A signed integer constant.",47,null],[13,"Udata","","An unsigned integer constant.",47,null],[13,"Exprloc","","&quot;The information bytes contain a DWARF expression (see Section 2.5) or\nlocation description (see Section 2.6).&quot;",47,null],[13,"Flag","","A boolean typically used to describe the presence or absence of another\nattribute.",47,null],[13,"SecOffset","","An offset into another section. Which section this is an offset into\ndepends on context.",47,null],[13,"UnitRef","","An offset into the current compilation unit.",47,null],[13,"DebugInfoRef","","An offset into the current `.debug_info` section, but possibly a\ndifferent compilation unit from the current one.",47,null],[13,"DebugLineRef","","An offset into the `.debug_lines` section.",47,null],[13,"DebugLocRef","","An offset into the `.debug_loc` section.",47,null],[13,"DebugMacinfoRef","","An offset into the `.debug_macinfo` section.",47,null],[13,"DebugRangesRef","","An offset into the `.debug_ranges` section.",47,null],[13,"DebugTypesRef","","A type signature.",47,null],[13,"DebugStrRef","","An offset into the `.debug_str` section.",47,null],[13,"String","","A null terminated C string, including the final null byte. Not\nguaranteed to be UTF-8 or anything like that.",47,null],[13,"Encoding","","The value of a `DW_AT_encoding` attribute.",47,null],[13,"DecimalSign","","The value of a `DW_AT_decimal_sign` attribute.",47,null],[13,"Endianity","","The value of a `DW_AT_endianity` attribute.",47,null],[13,"Accessibility","","The value of a `DW_AT_accessibility` attribute.",47,null],[13,"Visibility","","The value of a `DW_AT_visibility` attribute.",47,null],[13,"Virtuality","","The value of a `DW_AT_virtuality` attribute.",47,null],[13,"Language","","The value of a `DW_AT_language` attribute.",47,null],[13,"AddressClass","","The value of a `DW_AT_address_class` attribute.",47,null],[13,"IdentifierCase","","The value of a `DW_AT_identifier_case` attribute.",47,null],[13,"CallingConvention","","The value of a `DW_AT_calling_convention` attribute.",47,null],[13,"Inline","","The value of a `DW_AT_inline` attribute.",47,null],[13,"Ordering","","The value of a `DW_AT_ordering` attribute.",47,null],[13,"FileIndex","","An index into the filename entries from the line number information\ntable for the compilation unit containing this value.",47,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",48,null],[11,"fmt","","",48,null],[11,"new","","Construct a new `DebugFrame` instance from the data in the\n`.debug_frame` section.",48,null],[11,"entries","","Iterate over the `CommonInformationEntry`s and `FrameDescriptionEntry`s\nin this `.debug_frame` section.",48,null],[11,"cie_from_offset","","Parse the `CommonInformationEntry` at the given offset.",48,null],[11,"unwind_info_for_address","","Find the frame unwind information for the given address.",48,null],[11,"fmt","","",49,null],[11,"clone","","",49,null],[11,"next","","Advance the iterator to the next entry.",49,null],[11,"next","","",49,null],[11,"eq","","",36,null],[11,"ne","","",36,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"eq","","",50,null],[11,"ne","","",50,null],[11,"fmt","","",50,null],[11,"clone","","",50,null],[11,"instructions","","Iterate over this CIE&#39;s initial instructions.",50,null],[11,"eq","","",51,null],[11,"ne","","",51,null],[11,"fmt","","",51,null],[11,"clone","","",51,null],[11,"parse","","Fully parse this FDE.",51,null],[11,"eq","","",52,null],[11,"ne","","",52,null],[11,"fmt","","",52,null],[11,"clone","","",52,null],[11,"cie","","Get a reference to this FDE&#39;s CIE.",52,null],[11,"instructions","","Iterate over this FDE&#39;s instructions.",52,null],[11,"contains","","Return `true` if the given address is within this FDE, `false`\notherwise.",52,null],[11,"fmt","","",53,null],[11,"clone","","",53,null],[11,"new","","Construct a new call frame unwinding context.",53,{"inputs":[],"output":{"name":"uninitializedunwindcontext"}}],[11,"initialize","","Run the CIE&#39;s initial instructions, creating an\n`InitializedUnwindContext`.",53,null],[11,"fmt","","",54,null],[11,"clone","","",54,null],[11,"reset","","Reset this context to the uninitialized state.",54,null],[11,"fmt","","",55,null],[11,"new","","Construct a new `UnwindTable` for the given\n`FrameDescriptionEntry`&#39;s CFI unwinding program.",55,{"inputs":[{"name":"initializedunwindcontext"},{"name":"framedescriptionentry"}],"output":{"name":"unwindtable"}}],[11,"next_row","","Evaluate call frame instructions until the next row of the table is\ncompleted, and return it.",55,null],[11,"eq","","",56,null],[11,"ne","","",56,null],[11,"fmt","","",56,null],[11,"clone","","",56,null],[11,"default","","",56,{"inputs":[],"output":{"name":"self"}}],[11,"start_address","","Get the starting PC address that this row applies to.",56,null],[11,"end_address","","Get the end PC address where this row&#39;s register rules become\nunapplicable.",56,null],[11,"contains","","Return `true` if the given `address` is within this row&#39;s address range,\n`false` otherwise.",56,null],[11,"cfa","","Get the canonical frame address (CFA) recovery rule for this row.",56,null],[11,"registers","","Get the register recovery rules for this row.",56,null],[11,"eq","","",37,null],[11,"ne","","",37,null],[11,"fmt","","",37,null],[11,"clone","","",37,null],[11,"default","","",37,{"inputs":[],"output":{"name":"self"}}],[11,"eq","","",38,null],[11,"ne","","",38,null],[11,"fmt","","",38,null],[11,"clone","","",38,null],[11,"eq","","",39,null],[11,"ne","","",39,null],[11,"fmt","","",39,null],[11,"clone","","",39,null],[11,"fmt","","",57,null],[11,"clone","","",57,null],[11,"next","","Parse the next call frame instruction.",57,null],[11,"next","","",57,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",3,null],[11,"ne","","",3,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"fmt","","",3,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"fmt","","",4,null],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"clone","","",5,null],[11,"fmt","","",5,null],[11,"fmt","","",5,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"fmt","","",6,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"fmt","","",9,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"fmt","","",10,null],[11,"eq","","",11,null],[11,"ne","","",11,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"fmt","","",11,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"fmt","","",12,null],[11,"eq","","",13,null],[11,"ne","","",13,null],[11,"clone","","",13,null],[11,"fmt","","",13,null],[11,"fmt","","",13,null],[11,"eq","","",14,null],[11,"ne","","",14,null],[11,"clone","","",14,null],[11,"fmt","","",14,null],[11,"fmt","","",14,null],[11,"eq","","",15,null],[11,"ne","","",15,null],[11,"clone","","",15,null],[11,"fmt","","",15,null],[11,"fmt","","",15,null],[11,"eq","","",16,null],[11,"ne","","",16,null],[11,"clone","","",16,null],[11,"fmt","","",16,null],[11,"fmt","","",16,null],[11,"eq","","",17,null],[11,"ne","","",17,null],[11,"clone","","",17,null],[11,"fmt","","",17,null],[11,"fmt","","",17,null],[11,"eq","","",18,null],[11,"ne","","",18,null],[11,"clone","","",18,null],[11,"fmt","","",18,null],[11,"fmt","","",18,null],[11,"eq","","",19,null],[11,"ne","","",19,null],[11,"clone","","",19,null],[11,"fmt","","",19,null],[11,"fmt","","",19,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"clone","","",20,null],[11,"fmt","","",20,null],[11,"fmt","","",20,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"clone","","",21,null],[11,"fmt","","",21,null],[11,"fmt","","",21,null],[11,"eq","","",58,null],[11,"clone","","",58,null],[11,"fmt","","",58,null],[11,"read_u16","","",58,null],[11,"read_u32","","",58,null],[11,"read_u64","","",58,null],[11,"read_uint","","",58,null],[11,"write_u16","","",58,null],[11,"write_u32","","",58,null],[11,"write_u64","","",58,null],[11,"write_uint","","",58,null],[11,"eq","","",59,null],[11,"clone","","",59,null],[11,"fmt","","",59,null],[11,"read_u16","","",59,null],[11,"read_u32","","",59,null],[11,"read_u64","","",59,null],[11,"read_uint","","",59,null],[11,"write_u16","","",59,null],[11,"write_u32","","",59,null],[11,"write_u64","","",59,null],[11,"write_uint","","",59,null],[11,"eq","","",22,null],[11,"ne","","",22,null],[11,"clone","","",22,null],[11,"fmt","","",22,null],[11,"new","","Construct a new `EndianBuf` with the given buffer.",22,null],[11,"range","","Take the given `start..end` range of the underlying buffer and return a\nnew `EndianBuf`.",22,null],[11,"range_from","","Take the given `start..` range of the underlying buffer and return a new\n`EndianBuf`.",22,null],[11,"range_to","","Take the given `..end` range of the underlying buffer and return a new\n`EndianBuf`.",22,null],[11,"index","","",22,null],[11,"index","","",22,null],[11,"deref","","",22,null],[11,"into","","",22,null],[11,"eq","","",40,null],[11,"ne","","",40,null],[11,"clone","","",40,null],[11,"fmt","","",40,null],[11,"fmt","","",40,null],[11,"description","","",40,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"clone","","",23,null],[11,"fmt","","",23,null],[11,"eq","","",41,null],[11,"clone","","",41,null],[11,"fmt","","",41,null],[11,"eq","","",24,null],[11,"ne","","",24,null],[11,"clone","","",24,null],[11,"fmt","","",24,null],[11,"clone","","",60,null],[11,"fmt","","",60,null],[11,"new","","Construct a new `DebugAbbrev` instance from the data in the `.debug_abbrev`\nsection.",60,null],[11,"abbreviations","","Parse the abbreviations at the given `offset` within this\n`.debug_abbrev` section.",60,null],[11,"clone","","",61,null],[11,"default","","",61,{"inputs":[],"output":{"name":"abbreviations"}}],[11,"fmt","","",61,null],[11,"get","","Get the abbreviation associated with the given code.",61,null],[11,"eq","","",62,null],[11,"ne","","",62,null],[11,"clone","","",62,null],[11,"fmt","","",62,null],[11,"new","","Construct a new `Abbreviation`.",62,{"inputs":[{"name":"u64"},{"name":"dwtag"},{"name":"dwchildren"},{"name":"vec"}],"output":{"name":"abbreviation"}}],[11,"code","","Get this abbreviation&#39;s code.",62,null],[11,"tag","","Get this abbreviation&#39;s tag.",62,null],[11,"has_children","","Return true if this abbreviation&#39;s type has children, false otherwise.",62,null],[11,"attributes","","Get this abbreviation&#39;s attributes.",62,null],[11,"eq","","",63,null],[11,"ne","","",63,null],[11,"clone","","",63,null],[11,"fmt","","",63,null],[11,"new","","Construct a new `AttributeSpecification` from the given name and form.",63,{"inputs":[{"name":"dwat"},{"name":"dwform"}],"output":{"name":"attributespecification"}}],[11,"name","","Get the attribute&#39;s name.",63,null],[11,"form","","Get the attribute&#39;s form.",63,null],[11,"size","","Return the size of the attribute, in bytes.",63,null],[11,"clone","","",64,null],[11,"fmt","","",64,null],[11,"segment","","Return the segment selector of this arange.",64,null],[11,"address","","Return the beginning address of this arange.",64,null],[11,"length","","Return the length of this arange.",64,null],[11,"debug_info_offset","","Return the offset into the .debug_info section for this arange.",64,null],[11,"eq","","",64,null],[11,"partial_cmp","","",64,null],[11,"cmp","","",64,null],[11,"eq","","",25,null],[11,"ne","","",25,null],[11,"clone","","",25,null],[11,"fmt","","",25,null],[11,"clone","","",65,null],[11,"fmt","","",65,null],[11,"new","","Construct a new `DebugLine` instance from the data in the `.debug_line`\nsection.",65,null],[11,"header","","Parse the line number program header at the given `offset` in the\n`.debug_line` section.",65,null],[11,"fmt","","",66,null],[11,"header","","Get a reference to the header for this state machine&#39;s line number\nprogram.",66,null],[11,"next_row","","Parse and execute the next opcodes in the line number program until\nanother row in the line number matrix is computed.",66,null],[11,"run_to_address","","Parse and execute opcodes until we reach a row matching `addr`, the end of the program,\nor an error.",66,null],[11,"eq","","",42,null],[11,"ne","","",42,null],[11,"fmt","","",42,null],[11,"clone","","",42,null],[11,"fmt","","",42,null],[11,"fmt","","",67,null],[11,"next_opcode","","Advance the iterator and return the next opcode.",67,null],[11,"eq","","",68,null],[11,"ne","","",68,null],[11,"default","","",68,{"inputs":[],"output":{"name":"linenumberrow"}}],[11,"fmt","","",68,null],[11,"clone","","",68,null],[11,"address","","&quot;The program-counter value corresponding to a machine instruction\ngenerated by the compiler.&quot;",68,null],[11,"op_index","","&gt; An unsigned integer representing the index of an operation within a VLIW\n&gt; instruction. The index of the first operation is 0. For non-VLIW\n&gt; architectures, this register will always be 0.\n&gt;\n&gt; The address and op_index registers, taken together, form an operation\n&gt; pointer that can reference any individual operation with the\n&gt; instruction stream.",68,null],[11,"file_index","","&quot;An unsigned integer indicating the identity of the source file\ncorresponding to a machine instruction.&quot;",68,null],[11,"file","","The source file corresponding to the current machine instruction.",68,null],[11,"line","","&quot;An unsigned integer indicating a source line number. Lines are numbered\nbeginning at 1. The compiler may emit the value 0 in cases where an\ninstruction cannot be attributed to any source line.&quot;",68,null],[11,"column","","&quot;An unsigned integer indicating a column number within a source\nline. Columns are numbered beginning at 1. The value 0 is reserved to\nindicate that a statement begins at the “left edge” of the line.&quot;",68,null],[11,"is_stmt","","&quot;A boolean indicating that the current instruction is a recommended\nbreakpoint location. A recommended breakpoint location is intended to\n“represent” a line, a statement and/or a semantically distinct subpart\nof a statement.&quot;",68,null],[11,"basic_block","","&quot;A boolean indicating that the current instruction is the beginning of a\nbasic block.&quot;",68,null],[11,"end_sequence","","&quot;A boolean indicating that the current address is that of the first byte\nafter the end of a sequence of target machine instructions. end_sequence\nterminates a sequence of lines; therefore other information in the same\nrow is not meaningful.&quot;",68,null],[11,"prologue_end","","&quot;A boolean indicating that the current address is one (of possibly many)\nwhere execution should be suspended for an entry breakpoint of a\nfunction.&quot;",68,null],[11,"epilogue_begin","","&quot;A boolean indicating that the current address is one (of possibly many)\nwhere execution should be suspended for an exit breakpoint of a\nfunction.&quot;",68,null],[11,"isa","","Tag for the current instruction set architecture.",68,null],[11,"discriminator","","&quot;An unsigned integer identifying the block to which the current\ninstruction belongs. Discriminator values are assigned arbitrarily by\nthe DWARF producer and serve to distinguish among multiple blocks that\nmay all be associated with the same source file, line, and column. Where\nonly one block exists for a given source position, the discriminator\nvalue should be zero.&quot;",68,null],[11,"cmp","","",43,null],[11,"partial_cmp","","",43,null],[11,"lt","","",43,null],[11,"le","","",43,null],[11,"gt","","",43,null],[11,"ge","","",43,null],[11,"eq","","",43,null],[11,"ne","","",43,null],[11,"fmt","","",43,null],[11,"clone","","",43,null],[11,"eq","","",69,null],[11,"ne","","",69,null],[11,"fmt","","",69,null],[11,"clone","","",69,null],[11,"unit_length","","Return the length of the line number program and header, not including\nthe length of the encoded length itself.",69,null],[11,"version","","Get the version of this header&#39;s line program.",69,null],[11,"header_length","","Get the length of the encoded line number program header, not including\nthe length of the encoded length itself.",69,null],[11,"minimum_instruction_length","","Get the minimum instruction length any opcode in this header&#39;s line\nprogram may have.",69,null],[11,"maximum_operations_per_instruction","","Get the maximum number of operations each instruction in this header&#39;s\nline program may have.",69,null],[11,"default_is_stmt","","Get the default value of the `is_stmt` register for this header&#39;s line\nprogram.",69,null],[11,"line_base","","Get the line base for this header&#39;s line program.",69,null],[11,"line_range","","Get the line range for this header&#39;s line program.",69,null],[11,"opcode_base","","Get opcode base for this header&#39;s line program.",69,null],[11,"standard_opcode_lengths","","The byte lengths of each standard opcode in this header&#39;s line program.",69,null],[11,"include_directories","","Get the set of include directories for this header&#39;s line program.",69,null],[11,"directory","","The include directory with the given directory index.",69,null],[11,"file_names","","Get the list of source files that appear in this header&#39;s line program.",69,null],[11,"file","","The source file with the given file index.",69,null],[11,"opcodes","","Iterate over the opcodes in this header&#39;s line number program, parsing\nthem as we go.",69,null],[11,"rows","","Construct a new `StateMachine` for executing line programs and\ngenerating the line information matrix.",69,null],[11,"eq","","",70,null],[11,"ne","","",70,null],[11,"fmt","","",70,null],[11,"clone","","",70,null],[11,"path_name","","&gt; A null-terminated string containing the full or relative path name of\n&gt; a source file. If the entry contains a file name or a relative path\n&gt; name, the file is located relative to either the compilation directory\n&gt; (as specified by the DW_AT_comp_dir attribute given in the compilation\n&gt; unit) or one of the directories in the include_directories section.",70,null],[11,"directory_index","","&gt; An unsigned LEB128 number representing the directory index of the\n&gt; directory in which the file was found.\n&gt;\n&gt; ...\n&gt;\n&gt; The directory index represents an entry in the include_directories\n&gt; section of the line number program header. The index is 0 if the file\n&gt; was found in the current directory of the compilation, 1 if it was found\n&gt; in the first directory in the include_directories section, and so\n&gt; on. The directory index is ignored for file names that represent full\n&gt; path names.",70,null],[11,"directory","","Get this file&#39;s directory.",70,null],[11,"last_modification","","&quot;An unsigned LEB128 number representing the time of last modification of\nthe file, or 0 if not available.&quot;",70,null],[11,"length","","&quot;An unsigned LEB128 number representing the length in bytes of the file,\nor 0 if not available.&quot;",70,null],[11,"eq","","",26,null],[11,"ne","","",26,null],[11,"clone","","",26,null],[11,"fmt","","",26,null],[11,"clone","","",71,null],[11,"fmt","","",71,null],[11,"new","","Construct a new `DebugLoc` instance from the data in the `.debug_loc`\nsection.",71,null],[11,"locations","","Iterate over the `LocationListEntry`s starting at the given offset.",71,null],[11,"raw_locations","","Iterate over the raw `LocationListEntry`s starting at the given offset.",71,null],[11,"fmt","","",72,null],[11,"new","","Construct a `RawLocationListIter`.",72,{"inputs":[{"name":"endianbuf"},{"name":"u8"}],"output":{"name":"rawlocationlistiter"}}],[11,"next","","Advance the iterator to the next location.",72,null],[11,"next","","",72,null],[11,"fmt","","",73,null],[11,"next","","Advance the iterator to the next location.",73,null],[11,"next","","",73,null],[11,"eq","","",27,null],[11,"ne","","",27,null],[11,"clone","","",27,null],[11,"fmt","","",27,null],[11,"eq","","",44,null],[11,"ne","","",44,null],[11,"clone","","",44,null],[11,"fmt","","",44,null],[11,"eq","","",45,null],[11,"ne","","",45,null],[11,"fmt","","",45,null],[11,"eq","","",46,null],[11,"ne","","",46,null],[11,"fmt","","",46,null],[11,"eq","","",28,null],[11,"ne","","",28,null],[11,"fmt","","",28,null],[11,"parse","","Parse a single DWARF expression operation.",45,null],[11,"fmt","","",74,null],[11,"new","","Create a new DWARF expression evaluator.",74,null],[11,"set_initial_value","","Set an initial value to be pushed on the DWARF expression\nevaluator&#39;s stack.  This can be used in cases like\n`DW_AT_vtable_elem_location`, which require a value on the\nstack before evaluation commences.",74,null],[11,"set_object_address","","Set the enclosing object&#39;s address, as used by\n`DW_OP_push_object_address`",74,null],[11,"set_max_iterations","","Set the maximum number of iterations to be allowed by the\nexpression evaluator.  The default is `None`.  This value can\nbe set to avoid denial of service attacks by bad DWARF\nbytecode.",74,null],[11,"evaluate","","Evaluate a DWARF expression.",74,null],[11,"clone","","",75,null],[11,"fmt","","",75,null],[11,"name","","Returns the name this entry refers to.",75,null],[11,"info_offset","","Returns the offset into the .debug_info section for this name.",75,null],[11,"clone","","",76,null],[11,"fmt","","",76,null],[11,"name","","Returns the name of the type this entry refers to.",76,null],[11,"types_offset","","Returns the offset into the .debug_types section for this type.",76,null],[11,"eq","","",29,null],[11,"ne","","",29,null],[11,"clone","","",29,null],[11,"fmt","","",29,null],[11,"clone","","",77,null],[11,"fmt","","",77,null],[11,"new","","Construct a new `DebugRanges` instance from the data in the `.debug_ranges`\nsection.",77,null],[11,"ranges","","Iterate over the `Range` list entries starting at the given offset.",77,null],[11,"raw_ranges","","Iterate over the raw `Range` list entries starting at the given offset.",77,null],[11,"fmt","","",78,null],[11,"next","","Advance the iterator to the next range.",78,null],[11,"next","","",78,null],[11,"fmt","","",79,null],[11,"next","","Advance the iterator to the next range.",79,null],[11,"next","","",79,null],[11,"eq","","",30,null],[11,"ne","","",30,null],[11,"clone","","",30,null],[11,"fmt","","",30,null],[11,"is_end","","Check if this is a range end entry.",30,null],[11,"is_base_address","","Check if this is a base address selection entry.",30,null],[11,"add_base_address","","Add a base address to this range.",30,null],[11,"eq","","",31,null],[11,"ne","","",31,null],[11,"clone","","",31,null],[11,"fmt","","",31,null],[11,"clone","","",80,null],[11,"fmt","","",80,null],[11,"new","","Construct a new `DebugStr` instance from the data in the `.debug_str`\nsection.",80,null],[11,"get_str","","Lookup a string from the `.debug_str` section by DebugStrOffset.",80,null],[11,"eq","","",34,null],[11,"ne","","",34,null],[11,"clone","","",34,null],[11,"fmt","","",34,null],[11,"eq","","",35,null],[11,"ne","","",35,null],[11,"clone","","",35,null],[11,"fmt","","",35,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"clone","","",32,null],[11,"fmt","","",32,null],[11,"partial_cmp","","",33,null],[11,"lt","","",33,null],[11,"le","","",33,null],[11,"gt","","",33,null],[11,"ge","","",33,null],[11,"cmp","","",33,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"clone","","",33,null],[11,"fmt","","",33,null],[11,"clone","","",81,null],[11,"fmt","","",81,null],[11,"new","","Construct a new `DebugInfo` instance from the data in the `.debug_info`\nsection.",81,null],[11,"units","","Iterate the compilation- and partial-units in this\n`.debug_info` section.",81,null],[11,"header_from_offset","","Get the CompilationUnitHeader located at offset from this .debug_info section.",81,null],[11,"fmt","","",82,null],[11,"clone","","",82,null],[11,"next","","Advance the iterator to the next unit header.",82,null],[11,"next","","",82,null],[11,"eq","","",83,null],[11,"ne","","",83,null],[11,"clone","","",83,null],[11,"fmt","","",83,null],[11,"offset","","Get the offset of this compilation unit within the .debug_info section.",83,null],[11,"unit_length","","Get the length of the debugging info for this compilation unit, not\nincluding the byte length of the encoded length itself.",83,null],[11,"length_including_self","","Get the length of the debugging info for this compilation unit,\nincluding the byte length of the encoded length itself.",83,null],[11,"version","","Get the DWARF version of the debugging info for this compilation unit.",83,null],[11,"debug_abbrev_offset","","The offset into the `.debug_abbrev` section for this compilation unit&#39;s\ndebugging information entries&#39; abbreviations.",83,null],[11,"address_size","","The size of addresses (in bytes) in this type-unit.",83,null],[11,"format","","Whether this type unit is encoded in 64- or 32-bit DWARF.",83,null],[11,"header_size","","The serialized size of the header for this compilation unit.",83,null],[11,"entries","","Navigate this compilation unit&#39;s `DebuggingInformationEntry`s.",83,null],[11,"abbreviations","","Parse this compilation unit&#39;s abbreviations.",83,null],[11,"fmt","","",84,null],[11,"clone","","",84,null],[11,"code","","Get this entry&#39;s code.",84,null],[11,"offset","","Get this entry&#39;s offset.",84,null],[11,"tag","","Get this entry&#39;s `DW_TAG_whatever` tag.",84,null],[11,"has_children","","Return true if this entry&#39;s type can have children, false otherwise.",84,null],[11,"attrs","","Iterate over this entry&#39;s set of attributes.",84,null],[11,"attr","","Find the first attribute in this entry which has the given name,\nand return it. Returns `Ok(None)` if no attribute is found.",84,null],[11,"attr_value_raw","","Find the first attribute in this entry which has the given name,\nand return its raw value. Returns `Ok(None)` if no attribute is found.",84,null],[11,"attr_value","","Find the first attribute in this entry which has the given name,\nand return its normalized value.  Returns `Ok(None)` if no\nattribute is found.",84,null],[11,"eq","","",47,null],[11,"ne","","",47,null],[11,"fmt","","",47,null],[11,"clone","","",47,null],[11,"eq","","",85,null],[11,"ne","","",85,null],[11,"fmt","","",85,null],[11,"clone","","",85,null],[11,"name","","Get this attribute&#39;s name.",85,null],[11,"raw_value","","Get this attribute&#39;s raw value.",85,null],[11,"value","","Get this attribute&#39;s normalized value.",85,null],[11,"u8_value","","Try to convert this attribute&#39;s value to a u8.",85,null],[11,"u16_value","","Try to convert this attribute&#39;s value to a u16.",85,null],[11,"udata_value","","Try to convert this attribute&#39;s value to an unsigned integer.",85,null],[11,"offset_value","","Try to convert this attribute&#39;s value to an offset.",85,null],[11,"string_value","","Try to return this attribute&#39;s value as a string reference.",85,null],[11,"fmt","","",86,null],[11,"clone","","",86,null],[11,"next","","Advance the iterator and return the next attribute.",86,null],[11,"next","","",86,null],[11,"fmt","","",87,null],[11,"clone","","",87,null],[11,"current","","Get a reference to the entry that the cursor is currently pointing to.",87,null],[11,"next_entry","","Move the cursor to the next DIE in the tree.",87,null],[11,"next_dfs","","Move the cursor to the next DIE in the tree in DFS order.",87,null],[11,"next_sibling","","Move the cursor to the next sibling DIE of the current one.",87,null],[11,"clone","","",88,null],[11,"fmt","","",88,null],[11,"new","","Construct a new `DebugTypes` instance from the data in the `.debug_types`\nsection.",88,null],[11,"units","","Iterate the type-units in this `.debug_types` section.",88,null],[11,"fmt","","",89,null],[11,"clone","","",89,null],[11,"next","","Advance the iterator to the next type unit header.",89,null],[11,"next","","",89,null],[11,"eq","","",90,null],[11,"ne","","",90,null],[11,"clone","","",90,null],[11,"fmt","","",90,null],[11,"offset","","Get the offset of this compilation unit within the .debug_info section.",90,null],[11,"unit_length","","Get the length of the debugging info for this type-unit.",90,null],[11,"length_including_self","","Get the length of the debugging info for this type-unit,\nincluding the byte length of the encoded length itself.",90,null],[11,"version","","Get the DWARF version of the debugging info for this type-unit.",90,null],[11,"debug_abbrev_offset","","The offset into the `.debug_abbrev` section for this type-unit&#39;s\ndebugging information entries.",90,null],[11,"address_size","","The size of addresses (in bytes) in this type-unit.",90,null],[11,"format","","Whether this type unit is encoded in 64- or 32-bit DWARF.",90,null],[11,"header_size","","The serialized size of the header for this type-unit.",90,null],[11,"type_signature","","Get the unique type signature for this type unit.",90,null],[11,"type_offset","","Get the offset within this type unit where the type is defined.",90,null],[11,"entries","","Navigate this type unit&#39;s `DebuggingInformationEntry`s.",90,null],[11,"abbreviations","","Parse this type unit&#39;s abbreviations.",90,null],[6,"NativeEndian","","The native endianity for the target platform.",null,null],[6,"Result","","The result of a parse.",null,null],[6,"DebugAranges","","The `DebugAranges` struct represents the DWARF address range information\nfound in the `.debug_aranges` section.",null,null],[6,"ArangeEntryIter","","An iterator over the aranges from a `.debug_aranges` section.",null,null],[6,"DebugPubNames","","The `DebugPubNames` struct represents the DWARF public names information\nfound in the `.debug_pubnames` section.",null,null],[6,"PubNamesEntryIter","","An iterator over the pubnames from a `.debug_pubnames` section.",null,null],[6,"DebugPubTypes","","The `DebugPubTypes` struct represents the DWARF public types information\nfound in the `.debug_types` section.",null,null],[6,"PubTypesEntryIter","","An iterator over the pubtypes from a `.debug_pubtypes` section.",null,null],[17,"DW_CFA_advance_loc","","",null,null],[17,"DW_CFA_offset","","",null,null],[17,"DW_CFA_restore","","",null,null],[17,"DW_CFA_nop","","",null,null],[17,"DW_CFA_set_loc","","",null,null],[17,"DW_CFA_advance_loc1","","",null,null],[17,"DW_CFA_advance_loc2","","",null,null],[17,"DW_CFA_advance_loc4","","",null,null],[17,"DW_CFA_offset_extended","","",null,null],[17,"DW_CFA_restore_extended","","",null,null],[17,"DW_CFA_undefined","","",null,null],[17,"DW_CFA_same_value","","",null,null],[17,"DW_CFA_register","","",null,null],[17,"DW_CFA_remember_state","","",null,null],[17,"DW_CFA_restore_state","","",null,null],[17,"DW_CFA_def_cfa","","",null,null],[17,"DW_CFA_def_cfa_register","","",null,null],[17,"DW_CFA_def_cfa_offset","","",null,null],[17,"DW_CFA_def_cfa_expression","","",null,null],[17,"DW_CFA_expression","","",null,null],[17,"DW_CFA_offset_extended_sf","","",null,null],[17,"DW_CFA_def_cfa_sf","","",null,null],[17,"DW_CFA_def_cfa_offset_sf","","",null,null],[17,"DW_CFA_val_offset","","",null,null],[17,"DW_CFA_val_offset_sf","","",null,null],[17,"DW_CFA_val_expression","","",null,null],[17,"DW_CFA_lo_user","","",null,null],[17,"DW_CFA_hi_user","","",null,null],[17,"DW_CHILDREN_no","","",null,null],[17,"DW_CHILDREN_yes","","",null,null],[17,"DW_TAG_null","","",null,null],[17,"DW_TAG_array_type","","",null,null],[17,"DW_TAG_class_type","","",null,null],[17,"DW_TAG_entry_point","","",null,null],[17,"DW_TAG_enumeration_type","","",null,null],[17,"DW_TAG_formal_parameter","","",null,null],[17,"DW_TAG_imported_declaration","","",null,null],[17,"DW_TAG_label","","",null,null],[17,"DW_TAG_lexical_block","","",null,null],[17,"DW_TAG_member","","",null,null],[17,"DW_TAG_pointer_type","","",null,null],[17,"DW_TAG_reference_type","","",null,null],[17,"DW_TAG_compile_unit","","",null,null],[17,"DW_TAG_string_type","","",null,null],[17,"DW_TAG_structure_type","","",null,null],[17,"DW_TAG_subroutine_type","","",null,null],[17,"DW_TAG_typedef","","",null,null],[17,"DW_TAG_union_type","","",null,null],[17,"DW_TAG_unspecified_parameters","","",null,null],[17,"DW_TAG_variant","","",null,null],[17,"DW_TAG_common_block","","",null,null],[17,"DW_TAG_common_inclusion","","",null,null],[17,"DW_TAG_inheritance","","",null,null],[17,"DW_TAG_inlined_subroutine","","",null,null],[17,"DW_TAG_module","","",null,null],[17,"DW_TAG_ptr_to_member_type","","",null,null],[17,"DW_TAG_set_type","","",null,null],[17,"DW_TAG_subrange_type","","",null,null],[17,"DW_TAG_with_stmt","","",null,null],[17,"DW_TAG_access_declaration","","",null,null],[17,"DW_TAG_base_type","","",null,null],[17,"DW_TAG_catch_block","","",null,null],[17,"DW_TAG_const_type","","",null,null],[17,"DW_TAG_constant","","",null,null],[17,"DW_TAG_enumerator","","",null,null],[17,"DW_TAG_file_type","","",null,null],[17,"DW_TAG_friend","","",null,null],[17,"DW_TAG_namelist","","",null,null],[17,"DW_TAG_namelist_item","","",null,null],[17,"DW_TAG_packed_type","","",null,null],[17,"DW_TAG_subprogram","","",null,null],[17,"DW_TAG_template_type_parameter","","",null,null],[17,"DW_TAG_template_value_parameter","","",null,null],[17,"DW_TAG_thrown_type","","",null,null],[17,"DW_TAG_try_block","","",null,null],[17,"DW_TAG_variant_part","","",null,null],[17,"DW_TAG_variable","","",null,null],[17,"DW_TAG_volatile_type","","",null,null],[17,"DW_TAG_dwarf_procedure","","",null,null],[17,"DW_TAG_restrict_type","","",null,null],[17,"DW_TAG_interface_type","","",null,null],[17,"DW_TAG_namespace","","",null,null],[17,"DW_TAG_imported_module","","",null,null],[17,"DW_TAG_unspecified_type","","",null,null],[17,"DW_TAG_partial_unit","","",null,null],[17,"DW_TAG_imported_unit","","",null,null],[17,"DW_TAG_condition","","",null,null],[17,"DW_TAG_shared_type","","",null,null],[17,"DW_TAG_type_unit","","",null,null],[17,"DW_TAG_rvalue_reference_type","","",null,null],[17,"DW_TAG_template_alias","","",null,null],[17,"DW_TAG_lo_user","","",null,null],[17,"DW_TAG_hi_user","","",null,null],[17,"DW_AT_null","","",null,null],[17,"DW_AT_sibling","","",null,null],[17,"DW_AT_location","","",null,null],[17,"DW_AT_name","","",null,null],[17,"DW_AT_ordering","","",null,null],[17,"DW_AT_byte_size","","",null,null],[17,"DW_AT_bit_offset","","",null,null],[17,"DW_AT_bit_size","","",null,null],[17,"DW_AT_stmt_list","","",null,null],[17,"DW_AT_low_pc","","",null,null],[17,"DW_AT_high_pc","","",null,null],[17,"DW_AT_language","","",null,null],[17,"DW_AT_discr","","",null,null],[17,"DW_AT_discr_value","","",null,null],[17,"DW_AT_visibility","","",null,null],[17,"DW_AT_import","","",null,null],[17,"DW_AT_string_length","","",null,null],[17,"DW_AT_common_reference","","",null,null],[17,"DW_AT_comp_dir","","",null,null],[17,"DW_AT_const_value","","",null,null],[17,"DW_AT_containing_type","","",null,null],[17,"DW_AT_default_value","","",null,null],[17,"DW_AT_inline","","",null,null],[17,"DW_AT_is_optional","","",null,null],[17,"DW_AT_lower_bound","","",null,null],[17,"DW_AT_producer","","",null,null],[17,"DW_AT_prototyped","","",null,null],[17,"DW_AT_return_addr","","",null,null],[17,"DW_AT_start_scope","","",null,null],[17,"DW_AT_bit_stride","","",null,null],[17,"DW_AT_upper_bound","","",null,null],[17,"DW_AT_abstract_origin","","",null,null],[17,"DW_AT_accessibility","","",null,null],[17,"DW_AT_address_class","","",null,null],[17,"DW_AT_artificial","","",null,null],[17,"DW_AT_base_types","","",null,null],[17,"DW_AT_calling_convention","","",null,null],[17,"DW_AT_count","","",null,null],[17,"DW_AT_data_member_location","","",null,null],[17,"DW_AT_decl_column","","",null,null],[17,"DW_AT_decl_file","","",null,null],[17,"DW_AT_decl_line","","",null,null],[17,"DW_AT_declaration","","",null,null],[17,"DW_AT_discr_list","","",null,null],[17,"DW_AT_encoding","","",null,null],[17,"DW_AT_external","","",null,null],[17,"DW_AT_frame_base","","",null,null],[17,"DW_AT_friend","","",null,null],[17,"DW_AT_identifier_case","","",null,null],[17,"DW_AT_macro_info","","",null,null],[17,"DW_AT_namelist_item","","",null,null],[17,"DW_AT_priority","","",null,null],[17,"DW_AT_segment","","",null,null],[17,"DW_AT_specification","","",null,null],[17,"DW_AT_static_link","","",null,null],[17,"DW_AT_type","","",null,null],[17,"DW_AT_use_location","","",null,null],[17,"DW_AT_variable_parameter","","",null,null],[17,"DW_AT_virtuality","","",null,null],[17,"DW_AT_vtable_elem_location","","",null,null],[17,"DW_AT_allocated","","",null,null],[17,"DW_AT_associated","","",null,null],[17,"DW_AT_data_location","","",null,null],[17,"DW_AT_byte_stride","","",null,null],[17,"DW_AT_entry_pc","","",null,null],[17,"DW_AT_use_UTF8","","",null,null],[17,"DW_AT_extension","","",null,null],[17,"DW_AT_ranges","","",null,null],[17,"DW_AT_trampoline","","",null,null],[17,"DW_AT_call_column","","",null,null],[17,"DW_AT_call_file","","",null,null],[17,"DW_AT_call_line","","",null,null],[17,"DW_AT_description","","",null,null],[17,"DW_AT_binary_scale","","",null,null],[17,"DW_AT_decimal_scale","","",null,null],[17,"DW_AT_small","","",null,null],[17,"DW_AT_decimal_sign","","",null,null],[17,"DW_AT_digit_count","","",null,null],[17,"DW_AT_picture_string","","",null,null],[17,"DW_AT_mutable","","",null,null],[17,"DW_AT_threads_scaled","","",null,null],[17,"DW_AT_explicit","","",null,null],[17,"DW_AT_object_pointer","","",null,null],[17,"DW_AT_endianity","","",null,null],[17,"DW_AT_elemental","","",null,null],[17,"DW_AT_pure","","",null,null],[17,"DW_AT_recursive","","",null,null],[17,"DW_AT_signature","","",null,null],[17,"DW_AT_main_subprogram","","",null,null],[17,"DW_AT_data_bit_offset","","",null,null],[17,"DW_AT_const_expr","","",null,null],[17,"DW_AT_enum_class","","",null,null],[17,"DW_AT_linkage_name","","",null,null],[17,"DW_AT_lo_user","","",null,null],[17,"DW_AT_hi_user","","",null,null],[17,"DW_FORM_null","","",null,null],[17,"DW_FORM_addr","","",null,null],[17,"DW_FORM_block2","","",null,null],[17,"DW_FORM_block4","","",null,null],[17,"DW_FORM_data2","","",null,null],[17,"DW_FORM_data4","","",null,null],[17,"DW_FORM_data8","","",null,null],[17,"DW_FORM_string","","",null,null],[17,"DW_FORM_block","","",null,null],[17,"DW_FORM_block1","","",null,null],[17,"DW_FORM_data1","","",null,null],[17,"DW_FORM_flag","","",null,null],[17,"DW_FORM_sdata","","",null,null],[17,"DW_FORM_strp","","",null,null],[17,"DW_FORM_udata","","",null,null],[17,"DW_FORM_ref_addr","","",null,null],[17,"DW_FORM_ref1","","",null,null],[17,"DW_FORM_ref2","","",null,null],[17,"DW_FORM_ref4","","",null,null],[17,"DW_FORM_ref8","","",null,null],[17,"DW_FORM_ref_udata","","",null,null],[17,"DW_FORM_indirect","","",null,null],[17,"DW_FORM_sec_offset","","",null,null],[17,"DW_FORM_exprloc","","",null,null],[17,"DW_FORM_flag_present","","",null,null],[17,"DW_FORM_ref_sig8","","",null,null],[17,"DW_ATE_address","","",null,null],[17,"DW_ATE_boolean","","",null,null],[17,"DW_ATE_complex_float","","",null,null],[17,"DW_ATE_float","","",null,null],[17,"DW_ATE_signed","","",null,null],[17,"DW_ATE_signed_char","","",null,null],[17,"DW_ATE_unsigned","","",null,null],[17,"DW_ATE_unsigned_char","","",null,null],[17,"DW_ATE_imaginary_float","","",null,null],[17,"DW_ATE_packed_decimal","","",null,null],[17,"DW_ATE_numeric_string","","",null,null],[17,"DW_ATE_edited","","",null,null],[17,"DW_ATE_signed_fixed","","",null,null],[17,"DW_ATE_unsigned_fixed","","",null,null],[17,"DW_ATE_decimal_float","","",null,null],[17,"DW_ATE_UTF","","",null,null],[17,"DW_ATE_lo_user","","",null,null],[17,"DW_ATE_hi_user","","",null,null],[17,"DW_DS_unsigned","","",null,null],[17,"DW_DS_leading_overpunch","","",null,null],[17,"DW_DS_trailing_overpunch","","",null,null],[17,"DW_DS_leading_separate","","",null,null],[17,"DW_DS_trailing_separate","","",null,null],[17,"DW_END_public","","",null,null],[17,"DW_END_protected","","",null,null],[17,"DW_END_private","","",null,null],[17,"DW_END_lo_user","","",null,null],[17,"DW_END_hi_user","","",null,null],[17,"DW_ACCESS_public","","",null,null],[17,"DW_ACCESS_protected","","",null,null],[17,"DW_ACCESS_private","","",null,null],[17,"DW_VIS_local","","",null,null],[17,"DW_VIS_exported","","",null,null],[17,"DW_VIS_qualified","","",null,null],[17,"DW_VIRTUALITY_none","","",null,null],[17,"DW_VIRTUALITY_virtual","","",null,null],[17,"DW_VIRTUALITY_pure_virtual","","",null,null],[17,"DW_LANG_C89","","",null,null],[17,"DW_LANG_C","","",null,null],[17,"DW_LANG_Ada83","","",null,null],[17,"DW_LANG_C_plus_plus","","",null,null],[17,"DW_LANG_Cobol74","","",null,null],[17,"DW_LANG_Cobol85","","",null,null],[17,"DW_LANG_Fortran77","","",null,null],[17,"DW_LANG_Fortran90","","",null,null],[17,"DW_LANG_Pascal83","","",null,null],[17,"DW_LANG_Modula2","","",null,null],[17,"DW_LANG_Java","","",null,null],[17,"DW_LANG_C99","","",null,null],[17,"DW_LANG_Ada95","","",null,null],[17,"DW_LANG_Fortran95","","",null,null],[17,"DW_LANG_PLI","","",null,null],[17,"DW_LANG_ObjC","","",null,null],[17,"DW_LANG_ObjC_plus_plus","","",null,null],[17,"DW_LANG_UPC","","",null,null],[17,"DW_LANG_D","","",null,null],[17,"DW_LANG_Python","","",null,null],[17,"DW_LANG_Rust","","",null,null],[17,"DW_LANG_lo_user","","",null,null],[17,"DW_LANG_hi_user","","",null,null],[17,"DW_ADDR_none","","",null,null],[17,"DW_ID_case_sensitive","","",null,null],[17,"DW_ID_up_case","","",null,null],[17,"DW_ID_down_case","","",null,null],[17,"DW_ID_case_insensitive","","",null,null],[17,"DW_CC_normal","","",null,null],[17,"DW_CC_program","","",null,null],[17,"DW_CC_nocall","","",null,null],[17,"DW_CC_lo_user","","",null,null],[17,"DW_CC_hi_user","","",null,null],[17,"DW_INL_not_inlined","","",null,null],[17,"DW_INL_inlined","","",null,null],[17,"DW_INL_declared_not_inlined","","",null,null],[17,"DW_INL_declared_inlined","","",null,null],[17,"DW_ORD_row_major","","",null,null],[17,"DW_ORD_col_major","","",null,null],[17,"DW_DSC_label","","",null,null],[17,"DW_DSC_range","","",null,null],[17,"DW_LNS_copy","","",null,null],[17,"DW_LNS_advance_pc","","",null,null],[17,"DW_LNS_advance_line","","",null,null],[17,"DW_LNS_set_file","","",null,null],[17,"DW_LNS_set_column","","",null,null],[17,"DW_LNS_negate_stmt","","",null,null],[17,"DW_LNS_set_basic_block","","",null,null],[17,"DW_LNS_const_add_pc","","",null,null],[17,"DW_LNS_fixed_advance_pc","","",null,null],[17,"DW_LNS_set_prologue_end","","",null,null],[17,"DW_LNS_set_epilogue_begin","","",null,null],[17,"DW_LNS_set_isa","","",null,null],[17,"DW_LNE_end_sequence","","",null,null],[17,"DW_LNE_set_address","","",null,null],[17,"DW_LNE_define_file","","",null,null],[17,"DW_LNE_set_discriminator","","",null,null],[17,"DW_LNE_lo_user","","",null,null],[17,"DW_LNE_hi_user","","",null,null],[17,"DW_OP_addr","","",null,null],[17,"DW_OP_deref","","",null,null],[17,"DW_OP_const1u","","",null,null],[17,"DW_OP_const1s","","",null,null],[17,"DW_OP_const2u","","",null,null],[17,"DW_OP_const2s","","",null,null],[17,"DW_OP_const4u","","",null,null],[17,"DW_OP_const4s","","",null,null],[17,"DW_OP_const8u","","",null,null],[17,"DW_OP_const8s","","",null,null],[17,"DW_OP_constu","","",null,null],[17,"DW_OP_consts","","",null,null],[17,"DW_OP_dup","","",null,null],[17,"DW_OP_drop","","",null,null],[17,"DW_OP_over","","",null,null],[17,"DW_OP_pick","","",null,null],[17,"DW_OP_swap","","",null,null],[17,"DW_OP_rot","","",null,null],[17,"DW_OP_xderef","","",null,null],[17,"DW_OP_abs","","",null,null],[17,"DW_OP_and","","",null,null],[17,"DW_OP_div","","",null,null],[17,"DW_OP_minus","","",null,null],[17,"DW_OP_mod","","",null,null],[17,"DW_OP_mul","","",null,null],[17,"DW_OP_neg","","",null,null],[17,"DW_OP_not","","",null,null],[17,"DW_OP_or","","",null,null],[17,"DW_OP_plus","","",null,null],[17,"DW_OP_plus_uconst","","",null,null],[17,"DW_OP_shl","","",null,null],[17,"DW_OP_shr","","",null,null],[17,"DW_OP_shra","","",null,null],[17,"DW_OP_xor","","",null,null],[17,"DW_OP_bra","","",null,null],[17,"DW_OP_eq","","",null,null],[17,"DW_OP_ge","","",null,null],[17,"DW_OP_gt","","",null,null],[17,"DW_OP_le","","",null,null],[17,"DW_OP_lt","","",null,null],[17,"DW_OP_ne","","",null,null],[17,"DW_OP_skip","","",null,null],[17,"DW_OP_lit0","","",null,null],[17,"DW_OP_lit1","","",null,null],[17,"DW_OP_lit2","","",null,null],[17,"DW_OP_lit3","","",null,null],[17,"DW_OP_lit4","","",null,null],[17,"DW_OP_lit5","","",null,null],[17,"DW_OP_lit6","","",null,null],[17,"DW_OP_lit7","","",null,null],[17,"DW_OP_lit8","","",null,null],[17,"DW_OP_lit9","","",null,null],[17,"DW_OP_lit10","","",null,null],[17,"DW_OP_lit11","","",null,null],[17,"DW_OP_lit12","","",null,null],[17,"DW_OP_lit13","","",null,null],[17,"DW_OP_lit14","","",null,null],[17,"DW_OP_lit15","","",null,null],[17,"DW_OP_lit16","","",null,null],[17,"DW_OP_lit17","","",null,null],[17,"DW_OP_lit18","","",null,null],[17,"DW_OP_lit19","","",null,null],[17,"DW_OP_lit20","","",null,null],[17,"DW_OP_lit21","","",null,null],[17,"DW_OP_lit22","","",null,null],[17,"DW_OP_lit23","","",null,null],[17,"DW_OP_lit24","","",null,null],[17,"DW_OP_lit25","","",null,null],[17,"DW_OP_lit26","","",null,null],[17,"DW_OP_lit27","","",null,null],[17,"DW_OP_lit28","","",null,null],[17,"DW_OP_lit29","","",null,null],[17,"DW_OP_lit30","","",null,null],[17,"DW_OP_lit31","","",null,null],[17,"DW_OP_reg0","","",null,null],[17,"DW_OP_reg1","","",null,null],[17,"DW_OP_reg2","","",null,null],[17,"DW_OP_reg3","","",null,null],[17,"DW_OP_reg4","","",null,null],[17,"DW_OP_reg5","","",null,null],[17,"DW_OP_reg6","","",null,null],[17,"DW_OP_reg7","","",null,null],[17,"DW_OP_reg8","","",null,null],[17,"DW_OP_reg9","","",null,null],[17,"DW_OP_reg10","","",null,null],[17,"DW_OP_reg11","","",null,null],[17,"DW_OP_reg12","","",null,null],[17,"DW_OP_reg13","","",null,null],[17,"DW_OP_reg14","","",null,null],[17,"DW_OP_reg15","","",null,null],[17,"DW_OP_reg16","","",null,null],[17,"DW_OP_reg17","","",null,null],[17,"DW_OP_reg18","","",null,null],[17,"DW_OP_reg19","","",null,null],[17,"DW_OP_reg20","","",null,null],[17,"DW_OP_reg21","","",null,null],[17,"DW_OP_reg22","","",null,null],[17,"DW_OP_reg23","","",null,null],[17,"DW_OP_reg24","","",null,null],[17,"DW_OP_reg25","","",null,null],[17,"DW_OP_reg26","","",null,null],[17,"DW_OP_reg27","","",null,null],[17,"DW_OP_reg28","","",null,null],[17,"DW_OP_reg29","","",null,null],[17,"DW_OP_reg30","","",null,null],[17,"DW_OP_reg31","","",null,null],[17,"DW_OP_breg0","","",null,null],[17,"DW_OP_breg1","","",null,null],[17,"DW_OP_breg2","","",null,null],[17,"DW_OP_breg3","","",null,null],[17,"DW_OP_breg4","","",null,null],[17,"DW_OP_breg5","","",null,null],[17,"DW_OP_breg6","","",null,null],[17,"DW_OP_breg7","","",null,null],[17,"DW_OP_breg8","","",null,null],[17,"DW_OP_breg9","","",null,null],[17,"DW_OP_breg10","","",null,null],[17,"DW_OP_breg11","","",null,null],[17,"DW_OP_breg12","","",null,null],[17,"DW_OP_breg13","","",null,null],[17,"DW_OP_breg14","","",null,null],[17,"DW_OP_breg15","","",null,null],[17,"DW_OP_breg16","","",null,null],[17,"DW_OP_breg17","","",null,null],[17,"DW_OP_breg18","","",null,null],[17,"DW_OP_breg19","","",null,null],[17,"DW_OP_breg20","","",null,null],[17,"DW_OP_breg21","","",null,null],[17,"DW_OP_breg22","","",null,null],[17,"DW_OP_breg23","","",null,null],[17,"DW_OP_breg24","","",null,null],[17,"DW_OP_breg25","","",null,null],[17,"DW_OP_breg26","","",null,null],[17,"DW_OP_breg27","","",null,null],[17,"DW_OP_breg28","","",null,null],[17,"DW_OP_breg29","","",null,null],[17,"DW_OP_breg30","","",null,null],[17,"DW_OP_breg31","","",null,null],[17,"DW_OP_regx","","",null,null],[17,"DW_OP_fbreg","","",null,null],[17,"DW_OP_bregx","","",null,null],[17,"DW_OP_piece","","",null,null],[17,"DW_OP_deref_size","","",null,null],[17,"DW_OP_xderef_size","","",null,null],[17,"DW_OP_nop","","",null,null],[17,"DW_OP_push_object_address","","",null,null],[17,"DW_OP_call2","","",null,null],[17,"DW_OP_call4","","",null,null],[17,"DW_OP_call_ref","","",null,null],[17,"DW_OP_form_tls_address","","",null,null],[17,"DW_OP_call_frame_cfa","","",null,null],[17,"DW_OP_bit_piece","","",null,null],[17,"DW_OP_implicit_value","","",null,null],[17,"DW_OP_stack_value","","",null,null],[17,"DW_OP_GNU_push_tls_address","","",null,null],[8,"Endianity","","A trait describing the endianity of some buffer.",null,null],[8,"EvaluationContext","","Supply information to a DWARF expression evaluation.",null,null],[10,"read_memory","","Read the indicated number of bytes from memory at the\nindicated address.  The number of bytes is guaranteed to be\nless than the word size of the target architecture.",91,null],[10,"read_register","","Read the indicated register and return its value.",91,null],[10,"frame_base","","Compute the frame base using `DW_AT_frame_base`.",91,null],[10,"read_tls","","Compute the address of a thread-local variable.",91,null],[10,"call_frame_cfa","","Compute the call frame CFA.",91,null],[10,"get_at_location","","Find the `DW_AT_location` attribute of the given DIE and\nreturn the corresponding DWARF expression.  If no expression\ncan be found, this should return an empty slice.",91,null]],"paths":[[3,"DebugFrameOffset"],[3,"DwCfa"],[3,"DwChildren"],[3,"DwTag"],[3,"DwAt"],[3,"DwForm"],[3,"DwAte"],[3,"DwDs"],[3,"DwEnd"],[3,"DwAccess"],[3,"DwVis"],[3,"DwVirtuality"],[3,"DwLang"],[3,"DwAddr"],[3,"DwId"],[3,"DwCc"],[3,"DwInl"],[3,"DwOrd"],[3,"DwDsc"],[3,"DwLns"],[3,"DwLne"],[3,"DwOp"],[3,"EndianBuf"],[3,"DebugMacinfoOffset"],[3,"DebugAbbrevOffset"],[3,"DebugLineOffset"],[3,"DebugLocOffset"],[3,"LocationListEntry"],[3,"Piece"],[3,"DebugRangesOffset"],[3,"Range"],[3,"DebugStrOffset"],[3,"DebugInfoOffset"],[3,"UnitOffset"],[3,"DebugTypesOffset"],[3,"DebugTypeSignature"],[4,"CieOrFde"],[4,"CfaRule"],[4,"RegisterRule"],[4,"CallFrameInstruction"],[4,"Error"],[4,"Format"],[4,"Opcode"],[4,"ColumnType"],[4,"DieReference"],[4,"Operation"],[4,"Location"],[4,"AttributeValue"],[3,"DebugFrame"],[3,"CfiEntriesIter"],[3,"CommonInformationEntry"],[3,"PartialFrameDescriptionEntry"],[3,"FrameDescriptionEntry"],[3,"UninitializedUnwindContext"],[3,"InitializedUnwindContext"],[3,"UnwindTable"],[3,"UnwindTableRow"],[3,"CallFrameInstructionIter"],[4,"LittleEndian"],[4,"BigEndian"],[3,"DebugAbbrev"],[3,"Abbreviations"],[3,"Abbreviation"],[3,"AttributeSpecification"],[3,"ArangeEntry"],[3,"DebugLine"],[3,"StateMachine"],[3,"OpcodesIter"],[3,"LineNumberRow"],[3,"LineNumberProgramHeader"],[3,"FileEntry"],[3,"DebugLoc"],[3,"RawLocationListIter"],[3,"LocationListIter"],[3,"Evaluation"],[3,"PubNamesEntry"],[3,"PubTypesEntry"],[3,"DebugRanges"],[3,"RawRangesIter"],[3,"RangesIter"],[3,"DebugStr"],[3,"DebugInfo"],[3,"CompilationUnitHeadersIter"],[3,"CompilationUnitHeader"],[3,"DebuggingInformationEntry"],[3,"Attribute"],[3,"AttrsIter"],[3,"EntriesCursor"],[3,"DebugTypes"],[3,"TypeUnitHeadersIter"],[3,"TypeUnitHeader"],[8,"EvaluationContext"]]};
searchIndex["fallible_iterator"] = {"doc":"&quot;Fallible&quot; iterators.","items":[[3,"AndThen","fallible_iterator","An iterator which applies a fallible transform to the elements of the\nunderlying iterator.",null,null],[3,"Chain","","An iterator which yields the elements of one iterator followed by another.",null,null],[3,"Cloned","","An iterator which clones the elements of the underlying iterator.",null,null],[3,"Convert","","A fallible iterator that wraps a normal iterator over `Result`s.",null,null],[3,"Enumerate","","An iterator that yields the iteration count as well as the values of the\nunderlying iterator.",null,null],[3,"Filter","","An iterator which uses a predicate to determine which values of the\nunderlying iterator should be yielded.",null,null],[3,"FilterMap","","An iterator which both filters and maps the values of the underlying\niterator.",null,null],[3,"Fuse","","An iterator that yields `Ok(None)` forever after the underlying iterator\nyields `Ok(None)` once.",null,null],[3,"Iterator","","A normal (non-fallible) iterator which wraps a fallible iterator.",null,null],[3,"Map","","An iterator which applies a transform to the elements of the underlying\niterator.",null,null],[3,"MapErr","","An iterator which applies a transform to the errors of the underlying\niterator.",null,null],[3,"Peekable","","An iterator which can look at the next element without consuming it.",null,null],[3,"Rev","","An iterator which yields elements of the underlying iterator in reverse\norder.",null,null],[3,"Take","","An iterator which yields a limited number of elements from the underlying\niterator.",null,null],[3,"Zip","","An iterator that yields pairs of this iterator&#39;s and another iterator&#39;s\nvalues.",null,null],[5,"convert","","Converts an `Iterator&lt;Item = Result&lt;T, E&gt;&gt;` into a `FallibleIterator&lt;Item = T, Error = E&gt;`.",null,{"inputs":[{"name":"i"}],"output":{"name":"convert"}}],[8,"FallibleIterator","","An `Iterator`-like trait that allows for calculation of items to fail.",null,null],[16,"Item","","The type being iterated over.",0,null],[16,"Error","","The error type.",0,null],[10,"next","","Advances the iterator and returns the next value.",0,null],[11,"size_hint","","Returns bounds on the remaining length of the iterator.",0,null],[11,"all","","Determines if all elements of this iterator match a predicate.",0,null],[11,"and_then","","Returns an iterator which applies a fallible transform to the elements\nof the underlying iterator.",0,null],[11,"any","","Determines if any element of this iterator matches a predicate.",0,null],[11,"by_ref","","Borrow an iterator rather than consuming it.",0,null],[11,"chain","","Returns an iterator which yields the elements of this iterator followed\nby another.",0,null],[11,"cloned","","Returns an iterator which clones all of its elements.",0,null],[11,"count","","Consumes the iterator, returning the number of remaining items.",0,null],[11,"collect","","Transforms the iterator into a collection.",0,null],[11,"enumerate","","Returns an iterator which yields the current iteration count as well\nas the value.",0,null],[11,"filter","","Returns an iterator which uses a predicate to determine which values\nshould be yielded.",0,null],[11,"filter_map","","Returns an iterator which both filters and maps.",0,null],[11,"find","","Returns the first element of the iterator that matches a predicate.",0,null],[11,"fuse","","Returns an iterator which yields this iterator&#39;s elements and ends after\nthe first `Ok(None)`.",0,null],[11,"fold","","Applies a function over the elements of the iterator, producing a single\nfinal value.",0,null],[11,"iterator","","Returns a normal (non-fallible) iterator over `Result&lt;Item, Error&gt;`.",0,null],[11,"last","","Returns the last element of the iterator.",0,null],[11,"map","","Returns an iterator which applies a transform to the elements of the\nunderlying iterator.",0,null],[11,"map_err","","Returns an iterator which applies a transform to the errors of the\nunderlying iterator.",0,null],[11,"max","","Returns the maximal element of the iterator.",0,null],[11,"max_by_key","","Returns the element of the iterator which gives the maximum value from\nthe function.",0,null],[11,"min","","Returns the minimal element of the iterator.",0,null],[11,"min_by_key","","Returns the element of the iterator which gives the minimum value from\nthe function.",0,null],[11,"nth","","Returns the `n`th element of the iterator.",0,null],[11,"peekable","","Returns an iterator that can peek at the next element without consuming\nit.",0,null],[11,"position","","Returns the position of the first element of this iterator that matches\na predicate.",0,null],[11,"rev","","Returns an iterator that yields this iterator&#39;s items in the opposite\norder.",0,null],[11,"take","","Returns an iterator that yields only the first `n` values of this\niterator.",0,null],[11,"zip","","Returns an iterator that yields pairs of this iterator&#39;s and another\niterator&#39;s values.",0,null],[11,"cmp","","Lexicographically compares the elements of this iterator to that of\nanother.",0,null],[11,"partial_cmp","","Lexicographically compares the elements of this iterator to that of\nanother.",0,null],[11,"eq","","Determines if the elements of this iterator are equal to those of\nanother.",0,null],[11,"ne","","Determines if the elements of this iterator are not equal to those of\nanother.",0,null],[11,"lt","","Determines if the elements of this iterator are lexicographically less\nthan those of another.",0,null],[11,"le","","Determines if the elements of this iterator are lexicographically less\nthan or equal to those of another.",0,null],[11,"gt","","Determines if the elements of this iterator are lexicographically\ngreater than those of another.",0,null],[11,"ge","","Determines if the elements of this iterator are lexicographically\ngreater than or equal to those of another.",0,null],[8,"DoubleEndedFallibleIterator","","A fallible iterator able to yield elements from both ends.",null,null],[10,"next_back","","Advances the end of the iterator, returning the last value.",1,null],[8,"FromFallibleIterator","","Conversion from a fallible iterator.",null,null],[10,"from_fallible_iterator","","Creates a value from a fallible iterator.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[8,"IntoFallibleIterator","","Conversion into a `FallibleIterator`.",null,null],[16,"Item","","The elements of the iterator.",3,null],[16,"Error","","The error value of the iterator.",3,null],[16,"IntoIter","","The iterator.",3,null],[10,"into_fallible_iterator","","Creates a fallible iterator from a value.",3,null],[11,"next","alloc::boxed","",4,null],[11,"size_hint","","",4,null],[11,"next_back","","",4,null],[11,"from_fallible_iterator","collections::vec","",5,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"from_fallible_iterator","std::collections::hash::set","",6,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"from_fallible_iterator","std::collections::hash::map","",7,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"from_fallible_iterator","collections::btree::set","",8,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"from_fallible_iterator","collections::btree::map","",9,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"fmt","fallible_iterator","",10,null],[11,"next","","",10,null],[11,"size_hint","","",10,null],[11,"fmt","","",11,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"count","","",11,null],[11,"next_back","","",11,null],[11,"fmt","","",12,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"count","","",12,null],[11,"next_back","","",12,null],[11,"fmt","","",13,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"next_back","","",13,null],[11,"fmt","","",14,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"count","","",14,null],[11,"fmt","","",15,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"next_back","","",15,null],[11,"fmt","","",16,null],[11,"next","","",16,null],[11,"size_hint","","",16,null],[11,"next_back","","",16,null],[11,"fmt","","",17,null],[11,"next","","",17,null],[11,"size_hint","","",17,null],[11,"count","","",17,null],[11,"fmt","","",18,null],[11,"next","","",18,null],[11,"size_hint","","",18,null],[11,"next_back","","",18,null],[11,"fmt","","",19,null],[11,"next","","",19,null],[11,"size_hint","","",19,null],[11,"count","","",19,null],[11,"next_back","","",19,null],[11,"fmt","","",20,null],[11,"next","","",20,null],[11,"size_hint","","",20,null],[11,"count","","",20,null],[11,"next_back","","",20,null],[11,"fmt","","",21,null],[11,"peek","","Returns a reference to the next value without advancing the iterator.",21,null],[11,"next","","",21,null],[11,"size_hint","","",21,null],[11,"fmt","","",22,null],[11,"next","","",22,null],[11,"size_hint","","",22,null],[11,"count","","",22,null],[11,"next_back","","",22,null],[11,"fmt","","",23,null],[11,"next","","",23,null],[11,"size_hint","","",23,null],[11,"fmt","","",24,null],[11,"next","","",24,null],[11,"size_hint","","",24,null]],"paths":[[8,"FallibleIterator"],[8,"DoubleEndedFallibleIterator"],[8,"FromFallibleIterator"],[8,"IntoFallibleIterator"],[3,"Box"],[3,"Vec"],[3,"HashSet"],[3,"HashMap"],[3,"BTreeSet"],[3,"BTreeMap"],[3,"AndThen"],[3,"Chain"],[3,"Cloned"],[3,"Convert"],[3,"Enumerate"],[3,"Filter"],[3,"FilterMap"],[3,"Fuse"],[3,"Iterator"],[3,"Map"],[3,"MapErr"],[3,"Peekable"],[3,"Rev"],[3,"Take"],[3,"Zip"]]};
searchIndex["byteorder"] = {"doc":"This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.","items":[[4,"BigEndian","byteorder","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[6,"NetworkEndian","","Defines network byte order serialization.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",2,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",2,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",2,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",2,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",2,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",2,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",2,null],[10,"write_uint","","Writes an unsigned integer `n` to `buf` using only `nbytes`.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",2,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",2,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",2,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",2,null],[11,"write_int","","Writes a signed integer `n` to `buf` using only `nbytes`.",2,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",2,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",2,null],[11,"read_u16","","",3,null],[11,"read_u32","","",3,null],[11,"read_u64","","",3,null],[11,"read_uint","","",3,null],[11,"write_u16","","",3,null],[11,"write_u32","","",3,null],[11,"write_u64","","",3,null],[11,"write_uint","","",3,null],[11,"read_u16","","",4,null],[11,"read_u32","","",4,null],[11,"read_u64","","",4,null],[11,"read_uint","","",4,null],[11,"write_u16","","",4,null],[11,"write_u32","","",4,null],[11,"write_u64","","",4,null],[11,"write_uint","","",4,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",0,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",0,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",0,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",0,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",0,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",0,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",0,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",0,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",0,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",0,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",0,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",0,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",1,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",1,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",1,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",1,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",1,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",1,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",1,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",1,null],[11,"write_uint","","Writes an unsigned n-bytes integer to the underlying writer.",1,null],[11,"write_int","","Writes a signed n-bytes integer to the underlying writer.",1,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",1,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",1,null]],"paths":[[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
searchIndex["leb128"] = {"doc":"Read and write DWARF&#39;s &quot;Little Endian Base 128&quot; (LEB128) variable length\ninteger encoding.","items":[[0,"read","leb128","A module for reading signed and unsigned integers that have been LEB128\nencoded.",null,null],[4,"Error","leb128::read","An enumeration of the possible errors that can occur when reading a\nnumber encoded with LEB128.",null,null],[13,"IoError","","There was an underlying IO error.",0,null],[13,"Overflow","","The number being read is larger than can be represented.",0,null],[5,"unsigned","","Read an unsigned LEB128 number from the given `std::io::Read`able and\nreturn it or an error if reading failed.",null,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[5,"signed","","Read a signed LEB128 number from the given `std::io::Read`able and\nreturn it or an error if reading failed.",null,{"inputs":[{"name":"r"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"from","","",0,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",0,null],[11,"description","","",0,null],[11,"cause","","",0,null],[0,"write","leb128","A module for writing integers encoded as LEB128.",null,null],[5,"unsigned","leb128::write","Write the given unsigned number using the LEB128 encoding to the given\n`std::io::Write`able. Returns the number of bytes written to `w`, or an\nerror if writing failed.",null,{"inputs":[{"name":"w"},{"name":"u64"}],"output":{"name":"result"}}],[5,"signed","","Write the given signed number using the LEB128 encoding to the given\n`std::io::Write`able. Returns the number of bytes written to `w`, or an\nerror if writing failed.",null,{"inputs":[{"name":"w"},{"name":"i64"}],"output":{"name":"result"}}]],"paths":[[4,"Error"]]};
initSearch(searchIndex);
